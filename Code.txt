/**
 * @OnlyCurrentDoc
 * Script para el flujo de trabajo completo de operaciones: Envasado, Adquisiciones y Dashboard.
 * Versión Final.
 */

// --- LÓGICA DE MENÚS Y DISPARADORES ---

function onOpen() {
  setupProjectSheets();
  const ui = SpreadsheetApp.getUi();
  
  ui.createMenu('Gestión de Operaciones')
    .addItem('🚀 Abrir Dashboard de Operaciones', 'showDashboard')
    .addSeparator()
    .addItem('🚚 Comanda Rutas', 'showComandaRutasDialog')
    .addSeparator()
    .addItem('📈 Analizar Adquisiciones', 'runPriceAnalysis')
    .addToUi();

  ui.createMenu('Módulo de Finanzas')
    .addItem('💰 Importar Movimientos', 'showImportMovementsDialog')
    .addItem('📊 Conciliar Ingresos (Ventas)', 'showConciliationDialog')
    .addItem('🛒 Conciliar Egresos (Compras)', 'showExpenseConciliationDialog')
    .addSeparator()
    .addItem('🔧 Formatear Teléfonos en Hoja Orders', 'formatPhoneNumbersInOrdersSheet')
    .addToUi();
}

function onEdit(e) {
  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();
  const row = range.getRow();
  const col = range.getColumn();
  if (sheetName === "Lista de Adquisiciones" && row > 1 && (col === 2 || col === 3)) {
    recalculateRowInventory(sheet, row);
  }
}

// --- SETUP & CONFIGURACIÓN ---

/**
 * Crea todas las hojas necesarias para la aplicación si no existen y notifica al usuario.
 */
function setupProjectSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const createdSheets = [];

  // Helper function to create a sheet with headers if it doesn't exist
  const ensureSheetExists = (sheetName, headers, index) => {
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName, index);
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
      sheet.setFrozenRows(1);
      createdSheets.push(sheetName);
    }
    return sheet;
  };

  // Define all required sheets and their headers
  const sheetsToEnsure = [
    { name: "Orders", headers: ["Order #", "Nombre y apellido", "Email", "Phone", "Shipping Address", "Shipping City", "Shipping Region", "Shipping Postcode", "Item Name", "Item SKU", "Item Quantity", "Item Price", "Line Total", "Tax Rate", "Tax Amount", "Importe total del pedido", "Payment Method", "Transaction ID", "Estado del pago"], index: 0 },
    { name: "SKU", headers: ["Nombre Producto", "Producto Base", "Formato Compra", "Cantidad Compra", "Unidad Compra", "Categoría", "Cantidad Venta", "Unidad Venta", "Proveedor", "Teléfono"], index: 1 },
    { name: "Proveedores", headers: ["Nombre", "Teléfono"], index: 2 },
    { name: "MovimientosBancarios", headers: ["MONTO", "DESCRIPCIÓN MOVIMIENTO", "FECHA", "SALDO", "N° DOCUMENTO", "SUCURSAL", "CARGO/ABONO", "Asignado a Pedido"], index: 3 },
    { name: "AsignacionesHistoricas", headers: ["ID_Pago", "ID_Pedido", "Nombre_Banco", "Nombre_Pedido", "Monto", "Fecha_Asignacion"], index: 4 },
    { name: "Lista de Envasado", headers: ["Cantidad", "Inventario", "Nombre Producto"], index: 5 },
    { name: "Lista de Adquisiciones", headers: ["Producto Base", "Cantidad a Comprar", "Formato de Compra", "Inventario Actual", "Unidad Inventario Actual", "Necesidad de Venta", "Unidad Venta", "Inventario al Finalizar", "Unidad Inventario Final", "Precio Adq. Anterior", "Precio Adq. HOY", "Proveedor"], index: 6 },
    { name: "ClientBankData", headers: ["PaymentIdentifier", "CustomerRUT", "CustomerName", "LastSeen"], index: 7 },
    { name: "Historico Adquisiciones", headers: ["ID", "Fecha de Registro", "Producto Base", "Formato de Compra Real", "Cantidad Real", "Unidad Real", "Precio Unitario", "Costo Total Real", "Proveedor"], index: 8 },
    { name: "CostosVenta", headers: ["Fecha", "Nombre Producto", "Costo Adquisicion"], index: 9 },
    { name: "Anomalías de Precios", headers: ["Fecha", "Nombre Producto", "Costo de Hoy", "Costo Promedio Histórico", "Desviación Estándar", "Nivel de Desviación (StdDevs)", "Mensaje"], index: 10 }
  ];

  sheetsToEnsure.forEach(sheetInfo => {
    ensureSheetExists(sheetInfo.name, sheetInfo.headers, sheetInfo.index);
  });
  
  // Special check for 'Asignado a Pedido' column in case the sheet already existed
  const movementsSheet = ss.getSheetByName("MovimientosBancarios");
  const currentMovementsHeaders = movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0];
  if (currentMovementsHeaders.indexOf("Asignado a Pedido") === -1) {
    movementsSheet.getRange(1, currentMovementsHeaders.length + 1).setValue("Asignado a Pedido").setFontWeight("bold");
  }

  if (createdSheets.length > 0) {
    SpreadsheetApp.getUi().alert(`Se han creado las siguientes hojas que faltaban para el correcto funcionamiento: ${createdSheets.join(', ')}.`);
  }
}

function approveMatch(paymentId, orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const movementsSheet = ss.getSheetByName("MovimientosBancarios");
    const ordersSheet = ss.getSheetByName("Orders");
    const assignmentsSheet = ss.getSheetByName("AsignacionesHistoricas");

    // --- Update MovimientosBancarios ---
    const paymentRowIndex = parseInt(paymentId.split('|')[1]);
    const assignedCol = movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0].indexOf("Asignado a Pedido") + 1;
    if (assignedCol === 0) throw new Error("No se encontró la columna 'Asignado a Pedido'.");
    
    const existingVal = movementsSheet.getRange(paymentRowIndex, assignedCol).getValue();
    if(existingVal) {
      return { status: "error", message: `Este pago ya ha sido asignado al pedido #${existingVal}.` };
    }
    movementsSheet.getRange(paymentRowIndex, assignedCol).setValue(orderId);
    
    const paymentData = movementsSheet.getRange(paymentRowIndex, 1, 1, assignedCol).getValues()[0];
    const paymentAmount = paymentData[movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0].indexOf("MONTO")];
    const paymentDesc = paymentData[movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0].indexOf("DESCRIPCIÓN MOVIMIENTO")];


    // --- Update Orders ---
    const ordersData = ordersSheet.getDataRange().getValues();
    const headers = ordersData.shift();
    const orderIdCol = 0; // Column A
    const statusCol = 7; // Column H
    
    let orderCustomerName = '';
    let rowsUpdated = 0;
    ordersData.forEach((row, index) => {
      if (String(row[orderIdCol]) === String(orderId)) {
        ordersSheet.getRange(index + 2, statusCol + 1).setValue("Procesando Conciliacion Aprobada");
        if (!orderCustomerName) {
            orderCustomerName = row[1]; // Column B
        }
        rowsUpdated++;
      }
    });
    
    if(rowsUpdated === 0) throw new Error(`No se encontraron filas para el pedido #${orderId} para actualizar.`);

    // --- Log to AsignacionesHistoricas ---
    if(assignmentsSheet) {
      assignmentsSheet.appendRow([paymentId, orderId, paymentDesc, orderCustomerName, paymentAmount, new Date()]);
    }
    
    // --- (NEW) Update ClientBankData ---
    const clientBankSheet = ss.getSheetByName("ClientBankData");
    if (clientBankSheet) {
      const paymentIdentifier = extractNameFromDescription(paymentDesc);
      const customerRUT = ordersData.find(r => String(r[orderIdCol]) === String(orderId))[16];
      
      if (paymentIdentifier && customerRUT) {
        const bankData = clientBankSheet.getDataRange().getValues();
        const identifierCol = 0;
        let existingRow = -1;
        
        for (let i = 1; i < bankData.length; i++) {
          if (bankData[i][identifierCol] === paymentIdentifier) {
            existingRow = i + 1;
            break;
          }
        }

        if (existingRow !== -1) {
          clientBankSheet.getRange(existingRow, 4).setValue(new Date());
        } else {
          clientBankSheet.appendRow([paymentIdentifier, customerRUT, orderCustomerName, new Date()]);
        }
      }
    }

    SpreadsheetApp.flush();
    return { status: "success", message: `Pedido #${orderId} asignado correctamente.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: e.toString() };
  }
}

function approveOrderForManagement(orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");

    const ordersData = ordersSheet.getDataRange().getValues();
    ordersData.shift(); // remove headers
    const orderIdCol = 0; // Column A
    const statusCol = 7; // Column H

    let updatedRows = 0;
    ordersData.forEach((row, index) => {
      if (String(row[orderIdCol]) === String(orderId)) {
        ordersSheet.getRange(index + 2, statusCol + 1).setValue("APROBADO POR GERENCIA");
        updatedRows++;
      }
    });

    if (updatedRows > 0) {
      SpreadsheetApp.flush();
      return { status: "success", message: `Pedido #${orderId} aprobado por gerencia.` };
    } else {
      return { status: "error", message: `No se encontró el pedido #${orderId}.` };
    }
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: e.toString() };
  }
}


// --- LÓGICA DE COMANDA RUTAS ---

function showComandaRutasDialog() {
  const html = HtmlService.createHtmlOutputFromFile('ComandaRutasDialog')
    .setWidth(1000)
    .setHeight(700);
  SpreadsheetApp.getUi().showModalDialog(html, 'Comanda Rutas');
}

function getTodaysCommunes() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontró la hoja "Orders".');
  }
  const lastRow = ordersSheet.getLastRow();
  if (lastRow < 2) return [];
  
  const communeRange = ordersSheet.getRange(2, 7, lastRow - 1, 1); // Column G
  const communeValues = communeRange.getValues().flat();
  
  const uniqueCommunes = [...new Set(communeValues)].filter(Boolean);
  return uniqueCommunes.sort();
}

function getOrdersForRouting() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontró la hoja "Orders".');
  }

  const lastRow = ordersSheet.getLastRow();
  if (lastRow < 2) return [];

  // Confirmed Columns: A, B, D, E, F, G, H. Van is O (assumed).
  // A(0): Order #, B(1): Customer, D(3): Phone, E(4): Address, F(5): Dept, G(6): Commune, H(7): Status, O(14): Van
  const dataRange = ordersSheet.getRange(2, 1, lastRow - 1, 15); // Read up to column O for the van
  const values = dataRange.getValues();

  const uniqueOrders = {};
  values.forEach((row, index) => {
    const orderId = row[0];
    if (orderId && !uniqueOrders[orderId]) {
      uniqueOrders[orderId] = {
        orderNumber: orderId,
        customerName: row[1] || '',
        phone: row[3] || '',
        address: row[4] || '',
        department: row[5] || '',
        commune: row[6] || '',
        status: row[7] || '',
        van: row[14] || '' // Just read the historical value
      };
    }
  });

  return Object.values(uniqueOrders);
}

function saveRouteChanges(updatedOrders) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontró la hoja "Orders".');
  }

  // Check if "Furgón" column exists, if not, add it at the end.
  const headers = ordersSheet.getRange(1, 1, 1, ordersSheet.getLastColumn()).getValues()[0];
  const vanHeader = 'Furgón';
  let vanColumn = headers.indexOf(vanHeader) + 1;
  
  if (vanColumn === 0) { // Not found
    vanColumn = ordersSheet.getLastColumn() + 1;
    ordersSheet.getRange(1, vanColumn).setValue(vanHeader).setFontWeight('bold');
  }

  const allOrderNumbers = ordersSheet.getRange("A2:A" + ordersSheet.getLastRow()).getValues().flat();
  
  updatedOrders.forEach(order => {
    allOrderNumbers.forEach((orderNumber, index) => {
      if (orderNumber === order.orderNumber) {
        const row = index + 2; // +2 because sheet is 1-based and we skipped header
        ordersSheet.getRange(row, 4).setValue(order.phone);       // Col D: Phone
        ordersSheet.getRange(row, 5).setValue(order.address);     // Col E: Address
        ordersSheet.getRange(row, 6).setValue(order.department);  // Col F: Department
        ordersSheet.getRange(row, 7).setValue(order.commune);     // Col G: Commune
        ordersSheet.getRange(row, vanColumn).setValue(order.van);
      }
    });
  });

  return { status: 'success', message: 'Cambios guardados con éxito.' };
}

function processRouteXLData(pastedText) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  const lines = pastedText.split('\n');
  const orderedOrderNumbers = lines.map(line => {
    const match = line.match(/#\d+/); // Assumes order numbers are formatted like #1234
    return match ? match[0] : null;
  }).filter(Boolean);

  if (orderedOrderNumbers.length === 0) {
    throw new Error("No se pudieron encontrar números de pedido válidos (ej: #1234) en el texto pegado.");
  }

  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) throw new Error('No se encontró la hoja "Orders".');
  const ordersData = ordersSheet.getDataRange().getValues();
  const headers = ordersData.shift();

  const ordersMap = {};
  ordersData.forEach(row => {
    const orderNumber = row[0];
    if (!ordersMap[orderNumber]) ordersMap[orderNumber] = [];
    ordersMap[orderNumber].push(row);
  });

  const sortedData = [];
  orderedOrderNumbers.forEach(orderNumber => {
    if (ordersMap[orderNumber]) {
      sortedData.push(...ordersMap[orderNumber]);
    }
  });

  let routeSheet = ss.getSheetByName("Ruta Optimizada");
  if (routeSheet) routeSheet.clear();
  else routeSheet = ss.insertSheet("Ruta Optimizada");

  routeSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  if (sortedData.length > 0) {
    routeSheet.getRange(2, 1, sortedData.length, sortedData[0].length).setValues(sortedData);
  }
  routeSheet.autoResizeColumns(1, headers.length);

  return { status: 'success', message: `Se ha creado la hoja "Ruta Optimizada" con ${orderedOrderNumbers.length} pedidos ordenados.` };
}

function generatePrintableRouteSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const routeSheet = ss.getSheetByName("Ruta Optimizada");
  if (!routeSheet) {
    throw new Error('Primero debe procesar los datos de RouteXL para crear la hoja "Ruta Optimizada".');
  }

  const routeData = routeSheet.getDataRange().getValues();
  routeData.shift(); // remove headers

  // --- 1. Create "Orden de Envasado (Ruta)" ---
  const orderSequence = [];
  const seenOrders = new Set();
  routeData.forEach(row => {
    const orderNumber = row[0]; // Col A
    if (orderNumber && !seenOrders.has(orderNumber)) {
        orderSequence.push(orderNumber);
        seenOrders.add(orderNumber);
    }
  });

  const finalPackagingData = [];
  orderSequence.forEach((orderNumber, index) => {
      routeData.forEach(row => {
          if (row[0] === orderNumber) {
              finalPackagingData.push([
                  index + 1,   // Orden Ruta
                  orderNumber, // Nº Pedido
                  row[9],      // Producto (Col J)
                  row[10]      // Cantidad (Col K)
              ]);
          }
      });
  });

  let packagingSheet = ss.getSheetByName("Orden de Envasado (Ruta)");
  if (packagingSheet) packagingSheet.clear();
  else packagingSheet = ss.insertSheet("Orden de Envasado (Ruta)");

  const packagingHeaders = ["Orden Ruta", "Nº Pedido", "Producto", "Cantidad"];
  packagingSheet.getRange("A1:D1").setValues([packagingHeaders]).setFontWeight('bold');
  if (finalPackagingData.length > 0) {
    packagingSheet.getRange(2, 1, finalPackagingData.length, 4).setValues(finalPackagingData);
  }
  packagingSheet.autoResizeColumns(1, 4);

  // --- 2. Create "Orden de Carga (Ruta)" ---
  const loadingData = [];
  orderSequence.forEach((orderNumber, index) => {
      const orderRow = routeData.find(row => row[0] === orderNumber);
      if(orderRow) {
        const address = orderRow[4] || ''; // Col E
        const dept = orderRow[5] || '';    // Col F
        const fullAddress = [address, dept].filter(Boolean).join(', ');
        
        loadingData.push([
          index + 1,        // Orden Carga
          orderNumber,      // Nº Pedido
          orderRow[1],      // Cliente (Col B)
          fullAddress,      // Dirección Completa
          orderRow[6],      // Comuna (Col G)
          orderRow[14] || ''// Furgón (Col O)
        ]);
      }
  });

  let loadingSheet = ss.getSheetByName("Orden de Carga (Ruta)");
  if (loadingSheet) loadingSheet.clear();
  else loadingSheet = ss.insertSheet("Orden de Carga (Ruta)");

  const loadingHeaders = ["Orden Carga", "Nº Pedido", "Cliente", "Dirección Completa", "Comuna", "Furgón"];
  loadingSheet.getRange("A1:F1").setValues([loadingHeaders]).setFontWeight('bold');
  if (loadingData.length > 0) {
    loadingSheet.getRange(2, 1, loadingData.length, 6).setValues(loadingData);
  }
  loadingSheet.autoResizeColumns(1, 6);

  return { status: 'success', message: 'Se han generado las hojas de Envasado y Carga.' };
}


// --- MÓDULO DE FINANZAS ---

function showImportMovementsDialog() {
  const html = HtmlService.createHtmlOutputFromFile('ImportMovementsDialog')
    .setWidth(600)
    .setHeight(400);
  SpreadsheetApp.getUi().showModalDialog(html, 'Importar Movimientos Bancarios');
}

function importBankMovements(data) {
  if (!data || typeof data !== 'string') {
    throw new Error("No se proporcionaron datos válidos para importar.");
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("MovimientosBancarios");
  if (!sheet) {
    throw new Error("No se encontró la hoja 'MovimientosBancarios'. Por favor, vuelve a abrir el documento para que se cree automáticamente.");
  }

  const newRows = data.trim().split('\n').map(line => line.split('\t'));
  if (newRows.length === 0) {
    return "No se encontraron filas para importar.";
  }

  // 1. Read existing data using a more robust method
  const allData = sheet.getDataRange().getValues();
  const headers = allData.shift(); // Remove header row
  const existingData = allData;   // The rest is existing data

  Logger.log(`Total historical rows read: ${existingData.length}`);

  // DEBUG: Key with Amount and Description
  const existingKeys = new Set(existingData.map(row => 
    `${String(row[0]).trim()}|${String(row[1]).trim()}`
  ));
  
  if (existingKeys.size > 0) {
    Logger.log(`Sample historical key (Amount + Desc): ${existingKeys.values().next().value}`);
  }

  // 3. Filter out duplicates from the new rows
  const rowsToInsert = [];
  let duplicateCount = 0;
  
  newRows.forEach((row, index) => {
    // DEBUG: Key with Amount and Description
    const key = `${String(row[0]).trim()}|${String(row[1]).trim()}`;
    if (index === 0) {
      Logger.log(`Sample new key (Amount + Desc): ${key}`);
      Logger.log(`Does historical set have this new key? ${existingKeys.has(key)}`);
    }
    if (!existingKeys.has(key)) {
      rowsToInsert.push(row);
      existingKeys.add(key); // Add new key to set to avoid duplicate imports in the same batch
    } else {
      duplicateCount++;
    }
  });

  // 4. Insert only the new, non-duplicate rows
  if (rowsToInsert.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, rowsToInsert.length, rowsToInsert[0].length).setValues(rowsToInsert);
  }

  // 5. Update the return message
  let message = `Importación completada.`;
  if (rowsToInsert.length > 0) {
    message += ` Se añadieron ${rowsToInsert.length} nuevos movimientos.`;
  }
  if (duplicateCount > 0) {
    message += ` Se omitieron ${duplicateCount} movimientos duplicados.`;
  }
  if (rowsToInsert.length === 0 && duplicateCount === 0) {
    message = "No se importó nada. Revisa los datos pegados.";
  }
  
  return message;
}

function showFinanceDashboard() {
  const html = HtmlService.createHtmlOutputFromFile('FinanceDashboardDialog')
    .setWidth(500)
    .setHeight(350);
  SpreadsheetApp.getUi().showModalDialog(html, 'Módulo de Finanzas');
}

function showConciliationDialog() {
  const html = HtmlService.createHtmlOutputFromFile('SalesReconciliationDialog')
    .setWidth(1000)
    .setHeight(700);
  SpreadsheetApp.getUi().showModalDialog(html, 'Conciliar Ingresos de Ventas');
}

function showExpenseConciliationDialog() {
  SpreadsheetApp.getUi().alert("Este módulo (Conciliar Egresos) será implementado en un próximo paso.");
}

function getReconciliationData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const movementsSheet = ss.getSheetByName("MovimientosBancarios");
  const ordersSheet = ss.getSheetByName("Orders");
  const clientBankSheet = ss.getSheetByName("ClientBankData");

  if (!movementsSheet || !ordersSheet || !clientBankSheet) {
    throw new Error("Una o más hojas requeridas no se encontraron: MovimientosBancarios, Orders, ClientBankData.");
  }

  // --- 1. Fetch all necessary data ---
  const movementsData = movementsSheet.getDataRange().getValues();
  const ordersData = ordersSheet.getDataRange().getValues();
  const clientBankData = clientBankSheet.getDataRange().getValues();

  // --- 2. Prepare initial lists ---
  const movementsHeaders = movementsData.shift();
  const assignedColIdx = movementsHeaders.indexOf("Asignado a Pedido");
  const chargeColIdx = movementsHeaders.indexOf("CARGO/ABONO");
  const amountColIdx = movementsHeaders.indexOf("MONTO");
  const descColIdx = movementsHeaders.indexOf("DESCRIPCIÓN MOVIMIENTO");
  const dateColIdx = movementsHeaders.indexOf("FECHA");

  let unassignedPayments = [];
  movementsData.forEach((row, index) => {
    if (row[chargeColIdx] === 'A' && !row[assignedColIdx]) {
      const amount = parseFloat(String(row[amountColIdx]).replace(/[^0-9,-]+/g,"").replace(",", "."));
      if (isNaN(amount) || amount <= 0) return;
      let paymentDate;
      const dateCell = row[dateColIdx];
      if (dateCell instanceof Date) paymentDate = dateCell;
      else if (typeof dateCell === 'string' && dateCell) paymentDate = parseDDMMYYYY(dateCell);
      if (!paymentDate || isNaN(paymentDate.getTime())) return;
      unassignedPayments.push({ amount, desc: row[descColIdx], date: paymentDate, extractedName: extractNameFromDescription(row[descColIdx]), paymentId: `row|${index + 2}` });
    }
  });

  ordersData.shift();
  const REAL_ORDER_ID_COL = 0, REAL_CUSTOMER_NAME_COL = 1, REAL_STATUS_COL = 7, REAL_ORDER_DATE_COL = 8, REAL_TOTAL_AMOUNT_COL = 15, REAL_PAYMENT_METHOD_COL = 18, REAL_PHONE_COL = 3, REAL_RUT_COL = 16;
  const pendingOrdersMap = {};
  ordersData.forEach((row, index) => {
    const orderId = row[REAL_ORDER_ID_COL];
    if (!orderId) return;
    const status = String(row[REAL_STATUS_COL]).trim();
    const method = row[REAL_PAYMENT_METHOD_COL];
    const orderDate = new Date(row[REAL_ORDER_DATE_COL]);
    const isEligible = (method === 'bacs' && (status === 'En Espera de Pago' || status === 'Procesando') && orderDate instanceof Date && !isNaN(orderDate));
    if (isEligible && !pendingOrdersMap[orderId]) {
       const totalAmount = parseFloat(String(row[REAL_TOTAL_AMOUNT_COL]).replace(/[^0-9,-]+/g,"").replace(",","."));
       if (isNaN(totalAmount) || totalAmount <= 0) return;
       pendingOrdersMap[orderId] = { orderId, customerName: row[REAL_CUSTOMER_NAME_COL], phone: row[REAL_PHONE_COL], normalizedPhone: normalizePhoneNumber(row[REAL_PHONE_COL]), totalAmount, date: orderDate, status, rowNumber: index + 2, customerRUT: row[REAL_RUT_COL] };
    }
  });
  let pendingOrders = Object.values(pendingOrdersMap);

  // --- 3. Matching Logic ---
  const historicalSuggestions = [], highConfidenceSuggestions = [], lowConfidenceSuggestions = [];
  const matchedPaymentIds = new Set(), matchedOrderIds = new Set();
  
  const clientBankMap = new Map(clientBankData.slice(1).map(row => [row[0], row[1]]));

  // Tier 1: Historical Matching
  unassignedPayments.forEach(payment => {
    const paymentIdentifier = payment.extractedName;
    const customerRUT = clientBankMap.get(paymentIdentifier);
    if (customerRUT) {
      const order = pendingOrders.find(o => o.customerRUT === customerRUT && !matchedOrderIds.has(o.orderId));
      if (order) {
        historicalSuggestions.push({ payment, order });
        matchedPaymentIds.add(payment.paymentId);
        matchedOrderIds.add(order.orderId);
      }
    }
  });

  // Tiers 2 & 3: Score-Based Matching
  unassignedPayments.filter(p => !matchedPaymentIds.has(p.paymentId)).forEach(payment => {
    let bestMatch = { order: null, score: 0, amountScore: 0, nameScore: 0, dateScore: 0 };
    pendingOrders.filter(o => !matchedOrderIds.has(o.orderId)).forEach(order => {
      if (payment.date < new Date(order.date.getTime() - 24*60*60*1000)) return;
      const amountDiff = Math.abs(payment.amount - order.totalAmount);
      let amountScore = 0;
      if (amountDiff === 0) amountScore = 100;
      else if (amountDiff < 5000) amountScore = 100 - (amountDiff / 50);
      else return; 
      const msPerDay = 1000 * 60 * 60 * 24;
      const dayDifference = Math.floor((new Date(payment.date.getFullYear(), payment.date.getMonth(), payment.date.getDate()) - new Date(order.date.getFullYear(), order.date.getMonth(), order.date.getDate())) / msPerDay);
      if (dayDifference < 0) return; 
      const dateScore = Math.max(0, 100 - (dayDifference * 10));
      if (dateScore <= 0 && dayDifference > 0) return;
      const nameScore = calculateNameSimilarity(payment.extractedName, order.customerName);
      if (nameScore < 20) return;
      const totalScore = (amountScore * 0.5) + (nameScore * 0.3) + (dateScore * 0.2);
      if (totalScore > bestMatch.score) bestMatch = { order, score: totalScore, amountScore, nameScore, dateScore };
    });

    if (bestMatch.order && bestMatch.score > 65) {
      const suggestion = { payment, order: bestMatch.order, score: Math.round(bestMatch.score), amountScore: Math.round(bestMatch.amountScore), nameScore: Math.round(bestMatch.nameScore), dateScore: Math.round(bestMatch.dateScore) };
      if (bestMatch.amountScore === 100) highConfidenceSuggestions.push(suggestion);
      else lowConfidenceSuggestions.push(suggestion);
      matchedPaymentIds.add(payment.paymentId);
      matchedOrderIds.add(bestMatch.order.orderId);
    }
  });

  // --- 4. Prepare return data ---
  const formatDate = (date) => (date instanceof Date && !isNaN(date)) ? Utilities.formatDate(date, Session.getScriptTimeZone(), "dd/MM/yyyy") : "Fecha Inválida";
  const formatSuggestion = s => ({ ...s, payment: { ...s.payment, date: formatDate(s.payment.date) }, order: { ...s.order, date: formatDate(s.order.date) } });

  const manualListOrders = pendingOrders.filter(o => o.status === 'En Espera de Pago');

  return {
    historicalSuggestions: historicalSuggestions.map(formatSuggestion),
    highConfidenceSuggestions: highConfidenceSuggestions.map(formatSuggestion),
    lowConfidenceSuggestions: lowConfidenceSuggestions.map(formatSuggestion),
    unmatchedPayments: unassignedPayments.map(p => ({ ...p, date: formatDate(p.date) })),
    manualListOrders: manualListOrders.map(o => ({ ...o, date: formatDate(o.date) }))
  };
}


// --- LÓGICA DEL DASHBOARD ---

function showDashboard() {
  updateAcquisitionListAutomated(); // Actualiza la lista de adquisiciones automáticamente
  const html = HtmlService.createHtmlOutputFromFile('DashboardDialog')
    .setWidth(1200)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'Dashboard de Operaciones');
}

function startDashboardRefresh() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontró la hoja "Orders".');
  }
  const orderData = ordersSheet.getRange("A2:B" + ordersSheet.getLastRow()).getValues();
  const customerOrders = {};
  orderData.forEach(([orderNumber, customerName]) => {
    if (customerName) {
      if (!customerOrders[customerName]) customerOrders[customerName] = new Set();
      customerOrders[customerName].add(orderNumber);
    }
  });
  const duplicates = {};
  for (const customer in customerOrders) {
    if (customerOrders[customer].size > 1) {
      duplicates[customer] = Array.from(customerOrders[customer]);
    }
  }
  if (Object.keys(duplicates).length > 0) {
    showDuplicateDialog(duplicates);
  } else {
    checkForNewSuppliers();
  }
}

function showDuplicateDialog(duplicateData) {
  const template = HtmlService.createTemplateFromFile('DuplicateDialog');
  template.duplicates = JSON.stringify(duplicateData);
  const html = template.evaluate().setWidth(700).setHeight(500);
  SpreadsheetApp.getUi().showModalDialog(html, 'Resolver Pedidos Duplicados');
}

function deleteOrdersByNumber(orderNumbersToDelete) {
  if (!orderNumbersToDelete || orderNumbersToDelete.length === 0) return "No se seleccionó ningún pedido para eliminar.";
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Orders');
  const data = sheet.getDataRange().getValues();
  const rowsToDelete = [];
  for (let i = data.length - 1; i >= 1; i--) {
    if (orderNumbersToDelete.includes(String(data[i][0]))) {
      rowsToDelete.push(i + 1);
    }
  }
  if (rowsToDelete.length > 0) {
    rowsToDelete.forEach(rowNum => sheet.deleteRow(rowNum));
    checkForNewSuppliers();
    return `Se eliminaron ${rowsToDelete.length} filas. Continuando con el chequeo de proveedores...`;
  } else {
    return "No se encontraron los pedidos seleccionados.";
  }
}

function checkForNewSuppliers() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const skuSheet = ss.getSheetByName("SKU");
  const proveedoresSheet = ss.getSheetByName("Proveedores");
  if (!skuSheet || !proveedoresSheet) {
    SpreadsheetApp.getUi().alert("Faltan las hojas 'SKU' o 'Proveedores'.");
    return;
  }
  const skuSuppliers = new Set(skuSheet.getRange("I2:I" + skuSheet.getLastRow()).getValues().flat().filter(String));
  const existingSuppliers = new Set(proveedoresSheet.getRange("A2:A" + proveedoresSheet.getLastRow()).getValues().flat().filter(String));
  const newSuppliers = [...skuSuppliers].filter(s => !existingSuppliers.has(s));
  if (newSuppliers.length > 0) {
    showNewSupplierDialog(newSuppliers);
  } else {
    SpreadsheetApp.getUi().alert("Todos los datos están limpios y consistentes. Ahora puedes cargar las métricas en el dashboard.");
  }
}

function showNewSupplierDialog(newSuppliers) {
  const template = HtmlService.createTemplateFromFile('NewSupplierDialog');
  template.newSuppliers = JSON.stringify(newSuppliers);
  const html = template.evaluate().setWidth(600).setHeight(400);
  SpreadsheetApp.getUi().showModalDialog(html, 'Añadir Teléfonos de Proveedores Nuevos');
}

function saveNewSuppliers(supplierData) {
  const proveedoresSheet = ss.getSheetByName("Proveedores");
  const dataToAppend = Object.entries(supplierData);
  if (dataToAppend.length > 0) {
    proveedoresSheet.getRange(proveedoresSheet.getLastRow() + 1, 1, dataToAppend.length, 2).setValues(dataToAppend);
  }
  SpreadsheetApp.getUi().alert("Proveedores guardados. Ya puedes cargar las métricas en el dashboard.");
}

// --- FUNCIONES PÚBLICAS PARA EL DASHBOARD ---

function getDashboardSummaryMetrics() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');

    // --- Lógica de costos duplicada para independencia ---
    const costosSheet = ss.getSheetByName('CostosVenta');
    const productCostMap = {};
    if (costosSheet && costosSheet.getLastRow() > 1) {
      const costosData = costosSheet.getRange("B2:C" + costosSheet.getLastRow()).getValues();
      for (let i = costosData.length - 1; i >= 0; i--) {
        const row = costosData[i];
        const productName = row[0];
        const cost = parseFloat(row[1]);
        if (productName && !productCostMap[productName] && !isNaN(cost)) {
          productCostMap[productName] = cost;
        }
      }
    }
    // --- Fin de lógica duplicada ---

    let totalSales = 0;
    let totalCosts = 0;
    const orderIds = new Set();

    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("A2:M" + ordersSheet.getLastRow()).getValues();
        ordersData.forEach(row => {
            const orderId = row[0];
            const productName = row[9]; // Columna J: Nombre Producto
            const quantity = row[10];
            const lineTotal = row[12];

            if (orderId) orderIds.add(orderId);
            if (lineTotal) totalSales += parseFloat(lineTotal) || 0;

            if (productName && quantity && productCostMap[productName]) {
                totalCosts += productCostMap[productName] * (parseInt(quantity, 10) || 0);
            }
        });
    }

    const grossMargin = totalSales - totalCosts;
    const marginPercentage = totalSales > 0 ? (grossMargin / totalSales) * 100 : 0;

    return {
      totalSales: totalSales,
      orderCount: orderIds.size,
      grossMargin: grossMargin,
      marginPercentage: marginPercentage
    };
  } catch (e) {
    Logger.log(`ERROR en getDashboardSummaryMetrics: ${e.stack}`);
    return { error: `Error en Métricas de Resumen: ${e.message}` };
  }
}

function getDashboardCostMetrics() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const costosSheet = ss.getSheetByName('CostosVenta');

    const productCostMap = {};
    if (costosSheet && costosSheet.getLastRow() > 1) {
      const costosData = costosSheet.getRange("B2:C" + costosSheet.getLastRow()).getValues();
      for (let i = costosData.length - 1; i >= 0; i--) {
        const row = costosData[i];
        const productName = row[0];
        const cost = parseFloat(row[1]);
        if (productName && !productCostMap[productName] && !isNaN(cost)) {
          productCostMap[productName] = cost;
        }
      }
    }

    let totalCosts = 0;
    const productsWithoutCost = new Set();
    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("A2:K" + ordersSheet.getLastRow()).getValues();
        ordersData.forEach(row => {
            const productName = row[9]; // Columna J: Nombre Producto
            const quantity = row[10];   // Columna K
            if (productName && quantity) {
                if (productCostMap[productName]) {
                    totalCosts += productCostMap[productName] * (parseInt(quantity, 10) || 0);
                } else {
                    productsWithoutCost.add(productName);
                }
            }
        });
    }

    return {
      totalCosts: totalCosts,
      productsWithoutCostCount: productsWithoutCost.size,
      productsWithoutCostNames: Array.from(productsWithoutCost)
    };
  } catch (e) {
    Logger.log(`ERROR en getDashboardCostMetrics: ${e.stack}`);
    return { error: `Error en Métricas de Costos: ${e.message}` };
  }
}

function getDashboardTopProducts() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const productQuantities = {};

    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("J2:K" + ordersSheet.getLastRow()).getValues(); // Leer desde la columna J
        ordersData.forEach(row => {
            const productName = row[0]; // J es index 0 en este rango
            const quantity = row[1];    // K es index 1 en este rango
            if (productName && quantity) {
                productQuantities[productName] = (productQuantities[productName] || 0) + (parseInt(quantity, 10) || 0);
            }
        });
    }

    const topSoldProducts = Object.entries(productQuantities).sort(([, a], [, b]) => b - a).slice(0, 5);
    return topSoldProducts;
  } catch (e) {
    Logger.log(`ERROR en getDashboardTopProducts: ${e.stack}`);
    return { error: `Error en Top Productos: ${e.message}` };
  }
}

function getDashboardCommuneDistribution() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const communeCounts = {};

    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("A2:G" + ordersSheet.getLastRow()).getValues();
        ordersData.forEach(row => {
            const orderId = row[0];     // A es index 0
            const commune = row[6];     // G es index 6
            if (commune) {
                const orderKey = `${orderId}-${commune}`;
                if (!communeCounts[orderKey]) {
                    communeCounts[orderKey] = commune;
                }
            }
        });
    }

    const communeTally = {};
    Object.values(communeCounts).forEach(c => communeTally[c] = (communeTally[c] || 0) + 1);
    const communeDistribution = Object.entries(communeTally).sort(([, a], [, b]) => b - a);
    return communeDistribution;
  } catch (e) {
    Logger.log(`ERROR en getDashboardCommuneDistribution: ${e.stack}`);
    return { error: `Error en Distribución por Comuna: ${e.message}` };
  }
}


function futureModulePlaceholder() {
  SpreadsheetApp.getUi().alert("Este módulo será implementado en una futura actualización.");
}

// --- FLUJO DE ENVASADO ---

function startPackagingProcess() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  if (!ordersSheet || !skuSheet) {
    SpreadsheetApp.getUi().alert('Error: Faltan las hojas "Orders" o "SKU".');
    return;
  }
  const newProducts = getNewProducts(ordersSheet, skuSheet);
  if (newProducts.length > 0) {
    showBatchUpdateDialog(newProducts);
  } else {
    showCategorySelectionDialog();
  }
}

function showBatchUpdateDialog(productList) {
  const template = HtmlService.createTemplateFromFile('Dialog');
  template.productList = JSON.stringify(productList);
  const html = template.evaluate().setWidth(800).setHeight(600);
  SpreadsheetApp.getUi().showModalDialog(html, 'Paso 1: Añadir Nuevos Productos a SKU');
}

function saveSkuData(data) {
  const skuSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('SKU');
  skuSheet.appendRow([data.nombreProducto, data.productoBase, data.formato, data.cantidad, data.unidad, data.categoria, data.cantidadVenta, data.unidadVenta, '']);
  return { status: 'success' };
}

function triggerCategoryDialog() {
  showCategorySelectionDialog();
}

function showCategorySelectionDialog() {
  const html = HtmlService.createHtmlOutputFromFile('CategoryDialog').setWidth(500).setHeight(450);
  SpreadsheetApp.getUi().showModalDialog(html, 'Paso 2: Seleccionar Categorías para Envasado');
}

function getPackagingData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  const skuMap = getSkuMap(skuSheet);
  const orderData = ordersSheet.getRange("J2:K" + ordersSheet.getLastRow()).getValues();
  const productTotals = {};
  orderData.forEach(([name, qty]) => {
    if (name && qty) {
      if (!productTotals[name]) { productTotals[name] = 0; }
      productTotals[name] += parseInt(qty, 10) || 0;
    }
  });
  const categorySummary = {};
  for (const productName in productTotals) {
    const category = skuMap[productName] ? skuMap[productName].category : 'Sin Categoría';
    if (!categorySummary[category]) { categorySummary[category] = { count: 0, products: {} }; }
    categorySummary[category].count++;
    categorySummary[category].products[productName] = productTotals[productName];
  }
  return categorySummary;
}

function generatePackagingSheet(selectedCategories) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const data = getPackagingData();
  let sheet = ss.getSheetByName("Lista de Envasado");
  if (sheet) { sheet.clear(); } else { sheet = ss.insertSheet("Lista de Envasado"); }
  let currentRow = 1;
  sheet.getRange("A1:C1").setValues([["Cantidad", "Inventario", "Nombre Producto"]]).setFontWeight("bold");
  selectedCategories.sort().forEach(category => {
    currentRow++;
    sheet.getRange(currentRow, 1, 1, 3).merge().setValue(category.toUpperCase()).setFontWeight("bold").setHorizontalAlignment("center").setBackground("#f2f2f2");
    currentRow++;
    const products = data[category].products;
    const sortedProductNames = Object.keys(products).sort();
    sortedProductNames.forEach(productName => {
      sheet.getRange(currentRow, 1).setValue(products[productName]);
      sheet.getRange(currentRow, 3).setValue(productName);
      currentRow++;
    });
  });
  sheet.autoResizeColumns(1, 3);
  const printUrl = `https://docs.google.com/spreadsheets/d/${ss.getId()}/export?format=pdf&gid=${sheet.getSheetId()}&portrait=true&fitw=true&gridlines=false&printtitle=false`;
  return printUrl;
}

// --- FLUJO DE ADQUISICIONES ---

/**
 * Genera y guarda automáticamente la lista de adquisiciones.
 * Calcula las necesidades basadas en los pedidos y SKU, y luego guarda el plan.
 */
function updateAcquisitionListAutomated() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const skuSheet = ss.getSheetByName('SKU');

    if (!ordersSheet || !skuSheet) {
      Logger.log('Omitiendo actualización automática de adquisiciones: Faltan las hojas "Orders" o "SKU".');
      return;
    }

    // 1. Generar el plan de adquisiciones
    const { productToSkuMap, baseProductPurchaseOptions } = getPurchaseDataMaps(skuSheet);
    const baseProductNeeds = calculateBaseProductNeeds(ordersSheet, productToSkuMap);
    const acquisitionPlan = createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions);

    // 2. Transformar el plan al formato que espera `saveAcquisitions`
    const finalPlan = Object.values(acquisitionPlan).map(p => {
      const suggestedFormatString = `${p.suggestedFormat.name} (${p.suggestedFormat.size} ${p.suggestedFormat.unit})`;
      const allFormatStrings = p.availableFormats.map(f => `${f.name} (${f.size} ${f.unit})`);

      return {
        productName: p.productName,
        quantity: p.suggestedQty,
        selectedFormatString: suggestedFormatString,
        supplier: p.supplier,
        totalNeed: p.totalNeed,
        unit: p.unit,
        allFormatStrings: allFormatStrings,
        allFormatObjects: p.availableFormats.map(f => ({...f}))
      };
    });

    // 3. Guardar el plan utilizando la función existente
    // Esta función ya se encarga de limpiar la hoja, escribir encabezados y obtener el inventario actual.
    saveAcquisitions(finalPlan);
    Logger.log("La lista de adquisiciones se ha actualizado automáticamente.");

  } catch (e) {
    Logger.log(`Error durante la actualización automática de adquisiciones: ${e.toString()}`);
    // No mostramos una alerta al usuario para no ser intrusivos, pero lo registramos.
  }
}

function getAcquisitionDataForEditor() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  const proveedoresSheet = ss.getSheetByName('Proveedores');

  if (!ordersSheet || !skuSheet || !proveedoresSheet) {
    throw new Error('Faltan una o más hojas requeridas: "Orders", "SKU", o "Proveedores".');
  }

  // 1. Generar el plan de adquisiciones (lógica reutilizada)
  const { productToSkuMap, baseProductPurchaseOptions } = getPurchaseDataMaps(skuSheet);
  const baseProductNeeds = calculateBaseProductNeeds(ordersSheet, productToSkuMap);
  const acquisitionPlan = createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions);

  // 2. Obtener la lista de proveedores
  const supplierData = proveedoresSheet.getRange("A2:A" + proveedoresSheet.getLastRow()).getValues().flat().filter(String);
  const supplierSet = new Set(supplierData);
  supplierSet.add("Patio Mayorista"); // Asegurarse de que "Patio Mayorista" esté disponible

  // Convertir el plan de un objeto a un array para que sea más fácil de manejar en el lado del cliente
  const planAsArray = Object.values(acquisitionPlan);

  return {
    acquisitionPlan: planAsArray,
    allSuppliers: Array.from(supplierSet).sort()
  };
}

function showAcquisitionEditor() {
  const dataForEditor = getAcquisitionDataForEditor();
  const template = HtmlService.createTemplateFromFile('AcquisitionEditorDialog');
  // Pasar el objeto de datos directamente al template. La serialización se hará en el lado del cliente.
  template.data = dataForEditor;
  const html = template.evaluate().setWidth(1100).setHeight(700);
  SpreadsheetApp.getUi().showModalDialog(html, 'Editar Borrador de Adquisiciones');
}

function saveAcquisitions(finalPlan) {
  // finalPlan es un array de objetos desde el cliente.
  // Cada objeto: { productName, quantity, selectedFormatString, supplier, totalNeed, unit, allFormatStrings, allFormatObjects }
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName("Lista de Adquisiciones");
  if (sheet) {
    sheet.clear();
    sheet.clearConditionalFormatRules();
  } else {
    sheet = ss.insertSheet("Lista de Adquisiciones");
  }

  // Escribir datos en un formato plano para mayor robustez, con una columna de proveedor.
  const headers = ["Producto Base", "Cantidad a Comprar", "Formato de Compra", "Inventario Actual", "Unidad Inventario Actual", "Necesidad de Venta", "Unidad Venta", "Inventario al Finalizar", "Unidad Inventario Final", "Precio Adq. Anterior", "Precio Adq. HOY", "Proveedor"];
  sheet.getRange("A1:L1").setValues([headers]).setFontWeight("bold");
  sheet.getRange("A1:C1").setBackground("#d9ead3");
  sheet.getRange("D1:E1").setBackground("#fff2cc");
  sheet.getRange("F1:K1").setBackground("#f4cccc");
  sheet.getRange("L1").setBackground("#d9d9d9");
  sheet.setFrozenRows(1);

  const inventoryMap = getCurrentInventory(); // Get current inventory
  const priceMap = getHistoricalPrices(); // Get historical prices
  const dataToWrite = [];

  finalPlan.forEach(p => {
    const selectedFormatObject = p.allFormatObjects.find(f => `${f.name} (${f.size} ${f.unit})` === p.selectedFormatString);
    const formatSize = selectedFormatObject ? selectedFormatObject.size : 0;

    const currentInventory = inventoryMap[p.productName] || { quantity: 0, unit: p.unit };

    const purchasedAmount = (parseFloat(p.quantity) || 0) * formatSize;
    const finalInventory = currentInventory.quantity + purchasedAmount - (parseFloat(p.totalNeed) || 0);

    const history = priceMap[p.productName] || [];
    const precioHoy = history.length > 0 ? history[0].price : "";
    const precioAnterior = history.length > 1 ? history[1].price : "";

    const rowData = [
      p.productName,
      p.quantity,
      p.selectedFormatString,
      currentInventory.quantity, // Use actual inventory
      currentInventory.unit,     // Use actual inventory unit
      p.totalNeed,
      p.unit,
      finalInventory,
      p.unit,
      precioAnterior, // Columna J
      precioHoy,      // Columna K
      p.supplier || "Sin Proveedor"
    ];
    dataToWrite.push(rowData);
  });

  if (dataToWrite.length > 0) {
    sheet.getRange(2, 1, dataToWrite.length, headers.length).setValues(dataToWrite);

    // Aplicar la validación de datos a toda la columna de formato de una vez
    const formatColumnRange = sheet.getRange("C2:C" + (dataToWrite.length + 1));
    // Nota: Esta validación será la misma para todas las celdas (la del último producto).
    // Una validación por celda es necesaria si los formatos varían mucho.
    finalPlan.forEach((p, index) => {
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(p.allFormatStrings).build();
      sheet.getRange(index + 2, 3).setDataValidation(rule);
    });
  }

  sheet.autoResizeColumns(1, headers.length);

  return { status: "success", message: "Lista de adquisiciones guardada con éxito." };
}

function generateAcquisitionDRAFT() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  if (!ordersSheet || !skuSheet) {
    SpreadsheetApp.getUi().alert('Faltan las hojas "Orders" o "SKU".');
    return;
  }
  const { productToSkuMap, baseProductPurchaseOptions } = getPurchaseDataMaps(skuSheet);
  const baseProductNeeds = calculateBaseProductNeeds(ordersSheet, productToSkuMap);
  const acquisitionPlan = createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions);
  let sheet = ss.getSheetByName("Lista de Adquisiciones");
  if (sheet) {
    sheet.clear();
    sheet.clearConditionalFormatRules();
  } else {
    sheet = ss.insertSheet("Lista de Adquisiciones");
  }
  const headers = ["Producto Base", "Cantidad a Comprar", "Formato de Compra", "Inventario Actual", "Unidad Inventario Actual", "Necesidad de Venta", "Unidad Venta", "Inventario al Finalizar", "Unidad Inventario Final", "Precio Adq. Anterior", "Precio Adq. HOY"];
  sheet.getRange("A1:K1").setValues([headers]).setFontWeight("bold");
  sheet.getRange("A1:C1").setBackground("#d9ead3");
  sheet.getRange("D1:E1").setBackground("#fff2cc");
  sheet.getRange("F1:K1").setBackground("#f4cccc");
  sheet.setFrozenRows(1);
  const dataBySupplier = groupPlanBySupplier(acquisitionPlan);
  let currentRow = 2;
  const sortedSuppliers = Object.keys(dataBySupplier).sort();
  sortedSuppliers.forEach(supplier => {
    sheet.getRange(currentRow, 1, 1, headers.length).merge().setValue(supplier).setFontWeight("bold").setHorizontalAlignment("center").setBackground("#d9d9d9");
    currentRow++;
    const products = dataBySupplier[supplier];
    products.forEach(p => {
      const suggestedFormatString = `${p.suggestedFormat.name} (${p.suggestedFormat.size} ${p.suggestedFormat.unit})`;
      const totalComprado = p.suggestedQty * p.suggestedFormat.size;
      const inventarioFinal = 0 + totalComprado - p.totalNeed;
      sheet.getRange(currentRow, 1, 1, headers.length).setValues([[p.productName, p.suggestedQty, suggestedFormatString, 0, p.unit, p.totalNeed, p.saleUnit, inventarioFinal, p.unit, "", ""]]);
      const formatOptions = p.availableFormats.map(f => `${f.name} (${f.size} ${f.unit})`);
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(formatOptions).build();
      sheet.getRange(currentRow, 3).setDataValidation(rule);
      currentRow++;
    });
  });
  sheet.autoResizeColumns(1, headers.length);
  SpreadsheetApp.getUi().alert("Borrador de 'Lista de Adquisiciones' generado con éxito.");
}

function recalculateRowInventory(sheet, row) {
  const dataRange = sheet.getRange(`A${row}:H${row}`);
  const values = dataRange.getValues()[0];
  const [productoBase, cantidadAComprar, formatoDeCompra, inventarioActual, unidadInvActual, necesidadDeVenta, unidadVenta] = values;
  const multiplierMatch = String(formatoDeCompra).match(/\((\d+(\.\d+)?)/);
  const multiplier = multiplierMatch ? parseFloat(multiplierMatch[1]) : 0;
  const totalComprado = (parseFloat(String(cantidadAComprar).replace(",", ".")) || 0) * multiplier;
  const inventarioFinal = (parseFloat(String(inventarioActual).replace(",", ".")) || 0) + totalComprado - (parseFloat(String(necesidadDeVenta).replace(",", ".")) || 0);
  sheet.getRange(row, 8).setValue(inventarioFinal);
}

function startNotificationProcess() {
  const html = HtmlService.createHtmlOutputFromFile('NotificationDialog').setWidth(600).setHeight(400);
  SpreadsheetApp.getUi().showModalDialog(html, 'Panel de Notificación a Proveedores');
}

function getSupplierList() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const acquisitionsSheet = ss.getSheetByName("Lista de Adquisiciones");
  if (!acquisitionsSheet || acquisitionsSheet.getLastRow() < 2) {
    return [];
  }
  const supplierData = acquisitionsSheet.getRange("L2:L" + acquisitionsSheet.getLastRow()).getValues();
  const suppliers = new Set();
  supplierData.forEach(row => {
    if (row[0]) {
      suppliers.add(String(row[0]).trim());
    }
  });
  return Array.from(suppliers).sort();
}

function getOrdersForSupplier(supplierName) {
  if (!supplierName) {
    throw new Error("Se requiere un nombre de proveedor.");
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const acquisitionsSheet = ss.getSheetByName("Lista de Adquisiciones");
  const proveedoresSheet = ss.getSheetByName("Proveedores");
  const skuSheet = ss.getSheetByName("SKU");

  if (!acquisitionsSheet) throw new Error("No se encuentra la hoja 'Lista de Adquisiciones'.");
  if (!proveedoresSheet) throw new Error("No se encuentra la hoja 'Proveedores'.");
  if (!skuSheet) throw new Error("No se encuentra la hoja 'SKU'.");

  const phoneMapProveedores = new Map();
  if (proveedoresSheet.getLastRow() > 1) {
    const phoneData = proveedoresSheet.getRange("A2:B" + proveedoresSheet.getLastRow()).getValues();
    phoneData.forEach(([name, phone]) => {
      if (name && phone) phoneMapProveedores.set(String(name).trim(), String(phone).trim());
    });
  }
  const phoneMapSku = new Map();
  if (skuSheet.getLastRow() > 1) {
    const skuSupplierData = skuSheet.getRange("I2:J" + skuSheet.getLastRow()).getValues();
    skuSupplierData.forEach(([supplier, phone]) => {
      if (supplier && phone) {
        const supName = String(supplier).trim();
        if (!phoneMapSku.has(supName)) phoneMapSku.set(supName, String(phone).trim());
      }
    });
  }
  const phone = phoneMapProveedores.get(supplierName) || phoneMapSku.get(supplierName) || 'No encontrado';

  const orders = [];
  if (acquisitionsSheet.getLastRow() > 1) {
    const allData = acquisitionsSheet.getRange("A2:L" + acquisitionsSheet.getLastRow()).getValues();
    allData.forEach(row => {
      const [product, quantity, format, , , , , , , , , supplier] = row;
      if (supplier && String(supplier).trim() === supplierName) {
        if (product && quantity && parseFloat(String(quantity).replace(',', '.')) !== 0) {
          orders.push({
            product: String(product).trim(),
            quantity: quantity,
            format: String(format).trim()
          });
        }
      }
    });
  }

  return {
    phone: phone,
    orders: orders
  };
}

// --- MÓDULO DE ANÁLISIS DE PRECIOS ---

/**
 * Procesa la hoja "Reporte Adquisiciones" para registrar las compras diarias
 * en la hoja "Historico Adquisiciones", evitando duplicados.
 * Aplica la lógica de corrección de compras si los datos correspondientes están presentes.
 */
function procesarReporteAdquisiciones() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  const reporteSheet = ss.getSheetByName("Reporte Adquisiciones");
  if (!reporteSheet) {
    ui.alert('Error: No se encontró la hoja "Reporte Adquisiciones". Por favor, asegúrese de que la hoja exista y tenga ese nombre exacto.');
    return;
  }

  const historicoSheet = ss.getSheetByName("Historico Adquisiciones");
  if (!historicoSheet) {
    ui.alert('Error: No se encontró la hoja "Historico Adquisiciones". Por favor, ejecute el setup inicial desde el menú.');
    return;
  }

  try {
    const reporteData = reporteSheet.getDataRange().getValues();
    reporteData.shift(); // Quitar encabezados

    const historicoLastRow = historicoSheet.getLastRow();
    const existingIds = new Set();
    if (historicoLastRow > 1) {
      const historicoIds = historicoSheet.getRange(2, 1, historicoLastRow - 1, 1).getValues();
      historicoIds.forEach(row => {
        if (row[0]) existingIds.add(row[0].toString().trim());
      });
    }

    const newRowsToAppend = [];
    const today = new Date();

    reporteData.forEach(row => {
      // Mapeo de columnas (índice basado en 0)
      const ID_COL = 12;
      const ID = row[ID_COL] ? row[ID_COL].toString().trim() : null;

      if (!ID || ID === "" || existingIds.has(ID)) {
        return; // Omitir si no hay ID, está vacío o ya fue procesado
      }

      const PRODUCTO_BASE_COL = 1;
      const FORMATO_COMPRA_COL = 2;
      const CANTIDAD_COMPRA_COL = 3;
      const PRECIO_COMPRA_COL = 4;
      const TOTAL_COL = 5;
      const PROVEEDOR_COL = 6;

      const CORRECCION_CANTIDAD_COL = 8;
      const CORRECCION_FORMATO_COL = 9;
      const CORRECCION_FORMATO_CANT_COL = 10;
      const CORRECCION_FORMATO_UNIDAD_COL = 11;

      let cantidadReal, formatoReal, unidadReal;

      // Lógica de corrección
      if (row[CORRECCION_CANTIDAD_COL] && row[CORRECCION_CANTIDAD_COL] !== "") {
        cantidadReal = row[CORRECCION_CANTIDAD_COL];
        const formatoNombre = row[CORRECCION_FORMATO_COL] || '';
        const formatoCantidad = row[CORRECCION_FORMATO_CANT_COL] || '';
        const formatoUnidad = row[CORRECCION_FORMATO_UNIDAD_COL] || '';
        formatoReal = `${formatoNombre.toString().trim()} (${formatoCantidad} ${formatoUnidad.toString().trim()})`;
        unidadReal = formatoUnidad.toString().trim();
      } else {
        cantidadReal = row[CANTIDAD_COMPRA_COL];
        formatoReal = row[FORMATO_COMPRA_COL];
        const match = formatoReal.toString().match(/\((?:[\d.,]+|\s)*([a-zA-ZáéíóúÁÉÍÓÚñÑ]+)\)/);
        unidadReal = match && match[1] ? match[1] : 'Unidad'; // Fallback a "Unidad"
      }

      const newRow = [
        ID,                               // ID
        today,                            // Fecha de Registro
        row[PRODUCTO_BASE_COL],           // Producto Base
        formatoReal,                      // Formato de Compra Real
        cantidadReal,                     // Cantidad Real
        normalizeUnit(unidadReal),        // Unidad Real (usando helper existente)
        row[PRECIO_COMPRA_COL],           // Precio Unitario
        row[TOTAL_COL],                   // Costo Total Real
        row[PROVEEDOR_COL]                // Proveedor
      ];

      newRowsToAppend.push(newRow);
      existingIds.add(ID); // Añadir al set para evitar duplicados en la misma ejecución
    });

    if (newRowsToAppend.length > 0) {
      historicoSheet.getRange(historicoSheet.getLastRow() + 1, 1, newRowsToAppend.length, newRowsToAppend[0].length).setValues(newRowsToAppend);
      ui.alert(`Proceso completado. Se han añadido ${newRowsToAppend.length} nuevas adquisiciones al historial.`);
    } else {
      ui.alert('No se encontraron nuevas adquisiciones para procesar.');
    }

  } catch (e) {
    Logger.log(e);
    ui.alert(`Ha ocurrido un error durante el procesamiento: ${e.message}`);
  }
}

/**
 * Orquesta el proceso completo de análisis de precios,
 * llamando primero al procesamiento de adquisiciones y luego al cálculo de costos.
 */
function runPriceAnalysis() {
  try {
    procesarReporteAdquisiciones();
    const analysisData = getAnalysisData();
    showPriceApprovalDashboard(analysisData);
  } catch (e) {
    Logger.log(e);
    SpreadsheetApp.getUi().alert("Ocurrió un error en el proceso de análisis: " + e.message);
  }
}

/**
 * Analiza las adquisiciones del día, calcula los costos de venta y detecta anomalías.
 * @returns {{allCosts: Array<Array<any>>, anomalies: Array<object>}} Un objeto que contiene todos los costos calculados y una lista de anomalías detectadas.
 */
function getAnalysisData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const DEVIATION_THRESHOLD = 2.5;

  const historicoSheet = ss.getSheetByName("Historico Adquisiciones");
  const skuSheet = ss.getSheetByName("SKU");
  const costosSheet = ss.getSheetByName("CostosVenta");
  const ordersSheet = ss.getSheetByName("Orders");

  if (!historicoSheet || !skuSheet || !costosSheet || !ordersSheet) {
    throw new Error("Faltan una o más hojas requeridas. Ejecute el setup inicial.");
  }

  const historicoData = historicoSheet.getDataRange().getValues();
  const skuData = skuSheet.getDataRange().getValues();
  const costosData = costosSheet.getDataRange().getValues();
  const ordersData = ordersSheet.getDataRange().getValues();

  historicoData.shift();
  skuData.shift();
  costosData.shift();
  ordersData.shift();

  // Crear mapa de precios de venta (el más reciente por producto)
  const salePrices = {};
  const ORDERS_ITEM_NAME_COL = 8;
  const ORDERS_ITEM_PRICE_COL = 11;
  for (let i = ordersData.length - 1; i >= 0; i--) {
      const row = ordersData[i];
      const productName = row[ORDERS_ITEM_NAME_COL];
      const price = parseFloat(row[ORDERS_ITEM_PRICE_COL]);
      if (productName && !salePrices[productName] && price > 0) {
          salePrices[productName] = price;
      }
  }

  const skuMap = {};
  skuData.forEach(row => {
    const productoBase = row[1];
    if (!productoBase) return;
    if (!skuMap[productoBase]) skuMap[productoBase] = [];
    skuMap[productoBase].push({
      nombreProducto: row[0],
      cantidadVenta: parseFloat(String(row[6]).replace(',', '.')) || 0,
      unidadVenta: normalizeUnit(row[7])
    });
  });

  const historicalCosts = {};
  costosData.forEach(row => {
    const productName = row[1];
    const cost = parseFloat(row[2]);
    if (!productName || isNaN(cost)) return;
    if (!historicalCosts[productName]) historicalCosts[productName] = [];
    historicalCosts[productName].push(cost);
  });

  const analysisResults = [];
  const today = new Date();
  const todayString = today.toDateString();
  const processedProducts = new Set();

  const todayAcquisitions = historicoData.filter(acq => new Date(acq[1]).toDateString() === todayString);

  todayAcquisitions.forEach(acq => {
    const productoBase = acq[2];
    const formato = acq[3];
    const precioUnitario = parseFloat(String(acq[6]).replace(',', '.')) || 0;

    const match = formato.toString().match(/\((\d+(?:[.,]\d+)?)/);
    const formatoSize = match && match[1] ? parseFloat(match[1].replace(',', '.')) : 1;

    if (formatoSize === 0) return;
    const costoPorUnidadBase = precioUnitario / formatoSize;

    if (skuMap[productoBase]) {
      skuMap[productoBase].forEach(sku => {
        if (processedProducts.has(sku.nombreProducto)) return;

        const costoFinal = costoPorUnidadBase * sku.cantidadVenta;
        const history = historicalCosts[sku.nombreProducto] || [];
        const stats = calculateStats(history);

        let status = 'ok';
        let deviationLevel = 0;
        if (history.length < 2) {
            status = 'new';
        } else if (stats.stdDev > 0) {
            deviationLevel = (costoFinal - stats.mean) / stats.stdDev;
            if (Math.abs(deviationLevel) > DEVIATION_THRESHOLD) {
                status = 'anomaly';
            }
        }

        analysisResults.push({
          nombreProducto: sku.nombreProducto,
          costoHoy: costoFinal,
          status: status,
          productoBase: productoBase,
          formatoCompra: formato,
          proveedor: acq[8],
          precioUnitarioCompra: precioUnitario,
          costoPromedio: stats.mean,
          desviacionEstandar: stats.stdDev,
          nivelDesviacion: deviationLevel,
          precioVenta: salePrices[sku.nombreProducto] || 0
        });
        processedProducts.add(sku.nombreProducto);
      });
    }
  });

  return analysisResults;
}

/**
 * Muestra un diálogo modal con las anomalías de precios para su aprobación.
 * @param {object} analysisData - El objeto que contiene allCosts y anomalies.
 */
function showPriceApprovalDashboard(analysisData) {
  const template = HtmlService.createTemplateFromFile('PriceApprovalDialog');
  template.analysisResults = analysisData;

  const html = template.evaluate()
      .setWidth(900)
      .setHeight(600);

  SpreadsheetApp.getUi().showModalDialog(html, 'Revisar y Aprobar Precios de Adquisición');
}

/**
 * Guarda los datos de costos y anomalías aprobados en sus respectivas hojas.
 * Esta función es llamada desde el dashboard de aprobación.
 * @param {object} data - Un objeto que contiene las listas 'costs' y 'anomalies'.
 * @returns {string} Un mensaje de confirmación.
 */
function commitPriceData(data) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const costosSheet = ss.getSheetByName("CostosVenta");
  const anomaliasSheet = ss.getSheetByName("Anomalías de Precios");
  const today = new Date();
  const todayString = today.toDateString();

  try {
    // 1. Preparar los datos para escribir
    const costsToWrite = data.map(item => [today, item.nombreProducto, item.costoHoy]);

    const anomaliesToWrite = data
      .filter(item => item.status === 'anomaly')
      .map(a => [
        today, a.nombreProducto, a.costoHoy, a.costoPromedio, a.desviacionEstandar, a.nivelDesviacion,
        `Costo de hoy (${a.costoHoy.toFixed(2)}) se desvía en ${a.nivelDesviacion.toFixed(2)} stddevs.`
      ]);

    // 2. Guardar los costos de venta
    if (costsToWrite.length > 0) {
      const allCostosData = costosSheet.getDataRange().getValues();
      const rowsToDeleteCosts = [];
      allCostosData.forEach((row, index) => {
        if (index > 0 && new Date(row[0]).toDateString() === todayString) {
          rowsToDeleteCosts.push(index + 1);
        }
      });
      for (let i = rowsToDeleteCosts.length - 1; i >= 0; i--) {
        costosSheet.deleteRow(rowsToDeleteCosts[i]);
      }
      costosSheet.getRange(costosSheet.getLastRow() + 1, 1, costsToWrite.length, 3).setValues(costsToWrite);
    }

    // 3. Guardar las anomalías
    const allAnomaliasData = anomaliasSheet.getDataRange().getValues();
    const rowsToDeleteAnomalies = [];
    allAnomaliasData.forEach((row, index) => {
      if (index > 0 && new Date(row[0]).toDateString() === todayString) {
        rowsToDeleteAnomalies.push(index + 1);
      }
    });
    for (let i = rowsToDeleteAnomalies.length - 1; i >= 0; i--) {
      anomaliasSheet.deleteRow(rowsToDeleteAnomalies[i]);
    }

    if (anomaliesToWrite.length > 0) {
      anomaliasSheet.getRange(anomaliasSheet.getLastRow() + 1, 1, anomaliesToWrite.length, 7).setValues(anomaliesToWrite);
    }

    return "Los precios han sido aprobados y guardados correctamente.";

  } catch (e) {
    Logger.log(e);
    throw new Error("Ocurrió un error al guardar los datos: " + e.message);
  }
}


/**
 * Lee la hoja "Historico Adquisiciones" y devuelve un mapa de precios históricos por producto.
 * @returns {Object<string, Array<{date: Date, price: number}>>} Un mapa donde las claves son
 *   nombres de productos y los valores son arrays de objetos de precio, ordenados por fecha descendente.
 */
function getHistoricalPrices() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const historicoSheet = ss.getSheetByName("Historico Adquisiciones");
  const priceMap = {};

  if (!historicoSheet) {
    Logger.log("Advertencia: No se encontró la hoja 'Historico Adquisiciones'. No se mostrarán precios.");
    return priceMap;
  }

  const lastRow = historicoSheet.getLastRow();
  if (lastRow < 2) {
    return priceMap; // Hoja vacía o solo con encabezados
  }

  // Columnas: B (Fecha de Registro), C (Producto Base), G (Precio Unitario)
  const data = historicoSheet.getRange(2, 2, lastRow - 1, 6).getValues();

  data.forEach(row => {
    const date = row[0];        // de la columna B
    const productName = row[1]; // de la columna C
    const price = row[5];       // de la columna G

    if (productName && date && price) {
      if (!priceMap[productName]) {
        priceMap[productName] = [];
      }
      priceMap[productName].push({
        date: new Date(date),
        price: parseFloat(String(price).replace(",", ".")) || 0
      });
    }
  });

  // Ordenar los precios de cada producto por fecha, de más reciente a más antiguo
  for (const product in priceMap) {
    priceMap[product].sort((a, b) => b.date - a.date);
  }

  return priceMap;
}

function getCurrentInventory() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const inventorySheet = ss.getSheetByName("Inventario Actual");
  const inventoryMap = {};

  if (!inventorySheet) {
    Logger.log("Warning: La hoja 'Inventario Actual' no fue encontrada. El inventario actual será 0.");
    return inventoryMap;
  }

  const lastRow = inventorySheet.getLastRow();
  if (lastRow < 2) {
    return inventoryMap; // Sheet is empty or has only headers
  }

  // Read data from columns B (Producto Base), C (Cantidad Stock Real), D (Unidad Venta)
  const data = inventorySheet.getRange(2, 2, lastRow - 1, 3).getValues();

  data.forEach(row => {
    const productName = row[0]; // from column B
    const quantity = row[1];    // from column C
    const unit = row[2];        // from column D
    if (productName) {
      inventoryMap[productName] = {
        quantity: parseFloat(String(quantity).replace(",", ".")) || 0,
        unit: unit || ''
      };
    }
  });

  return inventoryMap;
}

// --- FUNCIONES AUXILIARES ---

/**
 * Calcula la media y la desviación estándar de una población de un array de números.
 * @param {number[]} data - Un array de números.
 * @returns {{mean: number, stdDev: number}} Un objeto con la media y la desviación estándar.
 */
function calculateStats(data) {
  if (!data || data.length === 0) {
    return { mean: 0, stdDev: 0 };
  }

  const n = data.length;
  const mean = data.reduce((a, b) => a + b, 0) / n;

  if (n < 2) {
    return { mean: mean, stdDev: 0 };
  }

  const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
  const stdDev = Math.sqrt(variance);

  return { mean: mean, stdDev: stdDev };
}

function parseDDMMYYYY(dateString) {
  if (!dateString || typeof dateString !== 'string') return null;
  const parts = dateString.split('/');
  if (parts.length !== 3) return null;
  // new Date(year, monthIndex, day)
  return new Date(parts[2], parts[1] - 1, parts[0]);
}

function extractNameFromDescription(description) {
  if (!description || typeof description !== 'string') return '';
  const match = description.match(/(?:transf de|de)\s(.+)/i);
  if (match && match[1]) {
    return match[1].replace(/[0-9]/g, '').trim();
  }
  let cleaned = description.replace(/transf/i, '')
                           .replace(/pago/i, '')
                           .replace(/[0-9]/g, '')
                           .trim();
  return cleaned;
}

function calculateNameSimilarity(nameFromPayment, nameFromOrder) {
  if (!nameFromPayment || !nameFromOrder) return 0;

  const normalize = (str) => str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").split(/\s+/);

  const wordsFromPayment = normalize(nameFromPayment);
  const wordsFromOrder = normalize(nameFromOrder);

  if (wordsFromPayment.length === 0 || wordsFromOrder.length === 0) return 0;

  let matches = 0;
  for (const pWord of wordsFromPayment) {
    for (const oWord of wordsFromOrder) {
      if (oWord.startsWith(pWord) || pWord.startsWith(oWord)) {
        matches++;
        break; 
      }
    }
  }
  
  return (matches / wordsFromPayment.length) * 100;
}

function normalizePhoneNumber(phone) {
  if (!phone) return '';
  const originalPhoneStr = String(phone);
  let phoneStr = originalPhoneStr.trim();

  // Clean up common prefixes like '=' or '+'
  if (phoneStr.startsWith('=') || phoneStr.startsWith('+')) {
    phoneStr = phoneStr.substring(1);
  }
  if (phoneStr.startsWith('+')) { // In case of '=+'
    phoneStr = phoneStr.substring(1);
  }

  // Handle the `...123` suffix
  if (phoneStr.endsWith('123')) {
    let coreNumber = phoneStr.slice(0, -3);
    if (coreNumber.length === 9 && coreNumber.startsWith('9')) {
      return `56${coreNumber}`;
    }
  }
  
  // Handle standard Chilean formats if the special suffix format didn't match
  if (phoneStr.startsWith('569') && phoneStr.length === 11) {
    return phoneStr;
  }
  if (phoneStr.length === 9 && phoneStr.startsWith('9')) {
    return `56${phoneStr}`;
  }
  if (phoneStr.length === 8) {
    return `569${phoneStr}`;
  }

  // Final Fallback: If no specific format was matched, strip all non-numeric characters.
  return originalPhoneStr.replace(/\D/g, '');
}

function getNewProducts(ordersSheet, skuSheet) {
  const ordersData = ordersSheet.getRange('J2:J' + ordersSheet.getLastRow()).getValues();
  const skuData = skuSheet.getRange('A2:A' + skuSheet.getLastRow()).getValues();
  const orderProducts = ordersData.map(row => row[0]).filter(String);
  const skuProducts = new Set(skuData.map(row => row[0]).filter(String));
  return [...new Set(orderProducts)].filter(product => !skuProducts.has(product));
}

function getSkuMap(skuSheet) {
  const skuData = skuSheet.getRange("A2:I" + skuSheet.getLastRow()).getValues();
  const skuMap = {};
  skuData.forEach(row => {
    let [name, base, format, qty, unit, category, saleQty, saleUnit, supplier] = row;
    if (name) {
      category = normalizeString(category);
      unit = normalizeUnit(unit);
      saleUnit = normalizeUnit(saleUnit);
      skuMap[name] = { base, format, qty, unit, category, saleQty, saleUnit, supplier };
    }
  });
  return skuMap;
}

function getPurchaseDataMaps(skuSheet) {
  const skuData = skuSheet.getRange("A2:I" + skuSheet.getLastRow()).getValues();
  const productToSkuMap = {};
  const baseProductPurchaseOptions = {};
  skuData.forEach(row => {
    const [nombreProducto, productoBase, formatoCompra, cantidadCompra, unidadCompra, cat, cantVenta, unidadVenta, proveedor] = row;
    if (nombreProducto) {
      productToSkuMap[nombreProducto] = {
        productoBase,
        cantidadVenta: parseFloat(String(cantVenta).replace(',', '.')) || 0,
        unidadVenta: normalizeUnit(unidadVenta)
      };
    }
    if (productoBase && formatoCompra) {
      if (!baseProductPurchaseOptions[productoBase]) {
        baseProductPurchaseOptions[productoBase] = { options: [], suppliers: new Set() };
      }
      baseProductPurchaseOptions[productoBase].options.push({
        name: formatoCompra,
        size: parseFloat(String(cantidadCompra).replace(',', '.')) || 0,
        unit: normalizeUnit(unidadCompra)
      });
      if (proveedor) baseProductPurchaseOptions[productoBase].suppliers.add(proveedor);
    }
  });
  return { productToSkuMap, baseProductPurchaseOptions };
}

function calculateBaseProductNeeds(ordersSheet, productToSkuMap) {
  const orderData = ordersSheet.getRange("J2:K" + ordersSheet.getLastRow()).getValues();
  const baseProductNeeds = {};
  orderData.forEach(([name, qty]) => {
    if (name && qty && productToSkuMap[name]) {
      const skuInfo = productToSkuMap[name];
      const baseProduct = skuInfo.productoBase;
      const saleUnit = normalizeUnit(skuInfo.unidadVenta);
      const totalSaleAmount = (parseInt(qty, 10) || 0) * skuInfo.cantidadVenta;
      if (!baseProductNeeds[baseProduct]) baseProductNeeds[baseProduct] = {};
      if (!baseProductNeeds[baseProduct][saleUnit]) baseProductNeeds[baseProduct][saleUnit] = 0;
      baseProductNeeds[baseProduct][saleUnit] += totalSaleAmount;
    }
  });
  return baseProductNeeds;
}

function createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions) {
  const acquisitionPlan = {};
  for (const baseProduct in baseProductNeeds) {
    if (baseProductPurchaseOptions[baseProduct]) {
      const needs = baseProductNeeds[baseProduct];
      const purchaseInfo = baseProductPurchaseOptions[baseProduct];
      const purchaseOptions = purchaseInfo.options;
      const needUnit = Object.keys(needs)[0];
      const totalNeed = needs[needUnit];
      let bestOption = null;
      let minWaste = Infinity;
      purchaseOptions.forEach((option) => {
        if (option.unit === needUnit && option.size > 0) {
          const numToBuy = Math.ceil(totalNeed / option.size);
          const waste = (numToBuy * option.size) - totalNeed;
          if (waste < minWaste) {
            minWaste = waste;
            bestOption = { ...option, suggestedQty: numToBuy };
          }
        }
      });
      if (bestOption) {
        acquisitionPlan[baseProduct] = {
          productName: baseProduct,
          totalNeed,
          unit: needUnit,
          saleUnit: needUnit,
          supplier: Array.from(purchaseInfo.suppliers).join(', '),
          availableFormats: purchaseOptions,
          suggestedFormat: bestOption,
          suggestedQty: bestOption.suggestedQty
        };
      }
    }
  }
  return acquisitionPlan;
}

function groupPlanBySupplier(acquisitionPlan) {
  const dataBySupplier = {};
  for (const productName in acquisitionPlan) {
    const productData = acquisitionPlan[productName];
    const supplier = productData.supplier || "Sin Proveedor";
    if (!dataBySupplier[supplier]) dataBySupplier[supplier] = [];
    dataBySupplier[supplier].push(productData);
  }
  return dataBySupplier;
}

function normalizeString(str) {
  if (!str || typeof str !== 'string') return '';
  return str.trim().toLowerCase().replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));
}

function normalizeUnit(str) {
  if (!str || typeof str !== 'string') return '';
  const s = str.trim().toLowerCase();
  if (s.startsWith('kilo')) { return 'Kg';}
  if (s.startsWith('gr')) { return 'Gr';}
  if (s.startsWith('unidad')) { return 'Unidad';}
  if (s.startsWith('bandeja')) { return 'Bandeja';}
  return normalizeString(s);
}

function getOAuthToken() {
  DriveApp.getFolderById('root'); // Force Drive scope.
  return ScriptApp.getOAuthToken();
}

function importOrdersFromXLSX(fileId) {
  let tempSheetId = null;
  try {
    const resource = {
      title: `[Temp] Importación de Pedidos - ${new Date().toISOString()}`,
      mimeType: MimeType.GOOGLE_SHEETS
    };
    const tempFile = Drive.Files.copy(resource, fileId);
    tempSheetId = tempFile.id;
    const tempSpreadsheet = SpreadsheetApp.openById(tempSheetId);
    const tempSheet = tempSpreadsheet.getSheets()[0];
    const data = tempSheet.getDataRange().getValues();
    if (!data || data.length < 2) {
      throw new Error("El archivo seleccionado está vacío o no tiene datos.");
    }
    const mainSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = mainSpreadsheet.getSheetByName("Orders");
    if (!ordersSheet) {
      throw new Error("No se encontró la hoja 'Orders' en el libro principal.");
    }
    ordersSheet.getRange("A2:Z").clearContent();
    ordersSheet.getRange(2, 1, data.length - 1, data[0].length).setValues(data.slice(1));
    return `¡Éxito! Se han importado ${data.length - 1} filas de pedidos.`;
  } catch (e) {
    Logger.log(`Error en importOrdersFromXLSX: ${e.toString()}`);
    throw new Error(`Ocurrió un error durante la importación: ${e.message}`);
  } finally {
    if (tempSheetId) {
      Drive.Files.remove(tempSheetId);
      Logger.log(`Archivo temporal eliminado: ${tempSheetId}`);
    }
  }
}

function formatPhoneNumbersInOrdersSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("Orders");
  if (!sheet) {
    SpreadsheetApp.getUi().alert("No se encontró la hoja 'Orders'.");
    return;
  }
  
  const phoneColumn = 4; // Column D
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    SpreadsheetApp.getUi().alert("No hay datos para formatear en la hoja 'Orders'.");
    return;
  }

  const phoneRange = sheet.getRange(2, phoneColumn, lastRow - 1, 1);
  const phoneValues = phoneRange.getValues();
  
  let changedCount = 0;
  const formattedPhones = phoneValues.map(row => {
    const originalPhone = row[0];
    if (!originalPhone) return [originalPhone];
    
    const formatted = normalizePhoneNumber(originalPhone);
    if (formatted !== originalPhone) {
      changedCount++;
    }
    return [formatted];
  });

  phoneRange.setValues(formattedPhones);
  
  SpreadsheetApp.getUi().alert(`Proceso completado. Se revisaron ${phoneValues.length} números. Se corrigieron ${changedCount} números de teléfono.`);
}
