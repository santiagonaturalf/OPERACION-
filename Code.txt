/**
 * @OnlyCurrentDoc
 * Script para el flujo de trabajo completo de operaciones: Envasado, Adquisiciones y Dashboard.
 * Versi贸n Final.
 */

// --- LGICA DE MENS Y DISPARADORES ---

function onOpen() {
  setupProjectSheets();
  const ui = SpreadsheetApp.getUi();
  
  ui.createMenu('Gesti贸n de Operaciones')
    .addItem(' Abrir Dashboard de Operaciones', 'showDashboard')
    .addSeparator()
    .addItem(' Comanda Rutas', 'showComandaRutasDialog')
    .addSeparator()
    .addItem(' Analizar Adquisiciones', 'runPriceAnalysis')
    .addToUi();

  ui.createMenu('M贸dulo de Finanzas')
    .addItem(' Importar Movimientos', 'showImportMovementsDialog')
    .addItem(' Conciliar Ingresos (Ventas)', 'showConciliationDialog')
    .addItem(' Conciliar Egresos (Compras)', 'showExpenseConciliationDialog')
    .addSeparator()
    .addItem(' Formatear Tel茅fonos en Hoja Orders', 'formatPhoneNumbersInOrdersSheet')
    .addToUi();
}

function onEdit(e) {
  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();
  const row = range.getRow();
  const col = range.getColumn();
  if (sheetName === "Lista de Adquisiciones" && row > 1 && (col === 2 || col === 3)) {
    recalculateRowInventory(sheet, row);
  }
}

// --- SETUP & CONFIGURACIN ---

/**
 * Crea todas las hojas necesarias para la aplicaci贸n si no existen y notifica al usuario.
 */
function setupProjectSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const createdSheets = [];

  // Helper function to create a sheet with headers if it doesn't exist
  const ensureSheetExists = (sheetName, headers, index) => {
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName, index);
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
      sheet.setFrozenRows(1);
      createdSheets.push(sheetName);
    }
    return sheet;
  };

  // Define all required sheets and their headers
  const sheetsToEnsure = [
    { name: "Orders", headers: ["Order #", "Nombre y apellido", "Email", "Phone", "Shipping Address", "Shipping City", "Shipping Region", "Shipping Postcode", "Item Name", "Item SKU", "Item Quantity", "Item Price", "Line Total", "Tax Rate", "Tax Amount", "Importe total del pedido", "Payment Method", "Transaction ID", "Estado del pago"], index: 0 },
    { name: "SKU", headers: ["Nombre Producto", "Producto Base", "Formato Compra", "Cantidad Compra", "Unidad Compra", "Categor铆a", "Cantidad Venta", "Unidad Venta", "Proveedor", "Tel茅fono"], index: 1 },
    { name: "Proveedores", headers: ["Nombre", "Tel茅fono"], index: 2 },
    { name: "MovimientosBancarios", headers: ["MONTO", "DESCRIPCIN MOVIMIENTO", "FECHA", "SALDO", "N掳 DOCUMENTO", "SUCURSAL", "CARGO/ABONO", "Asignado a Pedido"], index: 3 },
    { name: "AsignacionesHistoricas", headers: ["ID_Pago", "ID_Pedido", "Nombre_Banco", "Nombre_Pedido", "Monto", "Fecha_Asignacion"], index: 4 },
    { name: "Lista de Envasado", headers: ["Cantidad", "Inventario", "Nombre Producto"], index: 5 },
    { name: "Lista de Adquisiciones", headers: ["Producto Base", "Cantidad a Comprar", "Formato de Compra", "Inventario Actual", "Unidad Inventario Actual", "Necesidad de Venta", "Unidad Venta", "Inventario al Finalizar", "Unidad Inventario Final", "Precio Adq. Anterior", "Precio Adq. HOY", "Proveedor"], index: 6 },
    { name: "ClientBankData", headers: ["PaymentIdentifier", "CustomerRUT", "CustomerName", "LastSeen"], index: 7 },
    { name: "Historico Adquisiciones", headers: ["ID", "Fecha de Registro", "Producto Base", "Formato de Compra Real", "Cantidad Real", "Unidad Real", "Precio Unitario", "Costo Total Real", "Proveedor"], index: 8 },
    { name: "CostosVenta", headers: ["Fecha", "Nombre Producto", "Costo Adquisicion"], index: 9 },
    { name: "Anomal铆as de Precios", headers: ["Fecha", "Nombre Producto", "Costo de Hoy", "Costo Promedio Hist贸rico", "Desviaci贸n Est谩ndar", "Nivel de Desviaci贸n (StdDevs)", "Mensaje"], index: 10 }
  ];

  sheetsToEnsure.forEach(sheetInfo => {
    ensureSheetExists(sheetInfo.name, sheetInfo.headers, sheetInfo.index);
  });
  
  // Special check for 'Asignado a Pedido' column in case the sheet already existed
  const movementsSheet = ss.getSheetByName("MovimientosBancarios");
  const currentMovementsHeaders = movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0];
  if (currentMovementsHeaders.indexOf("Asignado a Pedido") === -1) {
    movementsSheet.getRange(1, currentMovementsHeaders.length + 1).setValue("Asignado a Pedido").setFontWeight("bold");
  }

  if (createdSheets.length > 0) {
    SpreadsheetApp.getUi().alert(`Se han creado las siguientes hojas que faltaban para el correcto funcionamiento: ${createdSheets.join(', ')}.`);
  }
}

function approveMatch(paymentId, orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const movementsSheet = ss.getSheetByName("MovimientosBancarios");
    const ordersSheet = ss.getSheetByName("Orders");
    const assignmentsSheet = ss.getSheetByName("AsignacionesHistoricas");

    // --- Update MovimientosBancarios ---
    const paymentRowIndex = parseInt(paymentId.split('|')[1]);
    const assignedCol = movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0].indexOf("Asignado a Pedido") + 1;
    if (assignedCol === 0) throw new Error("No se encontr贸 la columna 'Asignado a Pedido'.");
    
    const existingVal = movementsSheet.getRange(paymentRowIndex, assignedCol).getValue();
    if(existingVal) {
      return { status: "error", message: `Este pago ya ha sido asignado al pedido #${existingVal}.` };
    }
    movementsSheet.getRange(paymentRowIndex, assignedCol).setValue(orderId);
    
    const paymentData = movementsSheet.getRange(paymentRowIndex, 1, 1, assignedCol).getValues()[0];
    const paymentAmount = paymentData[movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0].indexOf("MONTO")];
    const paymentDesc = paymentData[movementsSheet.getRange(1, 1, 1, movementsSheet.getLastColumn()).getValues()[0].indexOf("DESCRIPCIN MOVIMIENTO")];


    // --- Update Orders ---
    const ordersData = ordersSheet.getDataRange().getValues();
    const headers = ordersData.shift();
    const orderIdCol = 0; // Column A
    const statusCol = 7; // Column H
    
    let orderCustomerName = '';
    let rowsUpdated = 0;
    ordersData.forEach((row, index) => {
      if (String(row[orderIdCol]) === String(orderId)) {
        ordersSheet.getRange(index + 2, statusCol + 1).setValue("Procesando Conciliacion Aprobada");
        if (!orderCustomerName) {
            orderCustomerName = row[1]; // Column B
        }
        rowsUpdated++;
      }
    });
    
    if(rowsUpdated === 0) throw new Error(`No se encontraron filas para el pedido #${orderId} para actualizar.`);

    // --- Log to AsignacionesHistoricas ---
    if(assignmentsSheet) {
      assignmentsSheet.appendRow([paymentId, orderId, paymentDesc, orderCustomerName, paymentAmount, new Date()]);
    }
    
    // --- (NEW) Update ClientBankData ---
    const clientBankSheet = ss.getSheetByName("ClientBankData");
    if (clientBankSheet) {
      const paymentIdentifier = extractNameFromDescription(paymentDesc);
      const customerRUT = ordersData.find(r => String(r[orderIdCol]) === String(orderId))[16];
      
      if (paymentIdentifier && customerRUT) {
        const bankData = clientBankSheet.getDataRange().getValues();
        const identifierCol = 0;
        let existingRow = -1;
        
        for (let i = 1; i < bankData.length; i++) {
          if (bankData[i][identifierCol] === paymentIdentifier) {
            existingRow = i + 1;
            break;
          }
        }

        if (existingRow !== -1) {
          clientBankSheet.getRange(existingRow, 4).setValue(new Date());
        } else {
          clientBankSheet.appendRow([paymentIdentifier, customerRUT, orderCustomerName, new Date()]);
        }
      }
    }

    SpreadsheetApp.flush();
    return { status: "success", message: `Pedido #${orderId} asignado correctamente.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: e.toString() };
  }
}

function approveOrderForManagement(orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");

    const ordersData = ordersSheet.getDataRange().getValues();
    ordersData.shift(); // remove headers
    const orderIdCol = 0; // Column A
    const statusCol = 7; // Column H

    let updatedRows = 0;
    ordersData.forEach((row, index) => {
      if (String(row[orderIdCol]) === String(orderId)) {
        ordersSheet.getRange(index + 2, statusCol + 1).setValue("APROBADO POR GERENCIA");
        updatedRows++;
      }
    });

    if (updatedRows > 0) {
      SpreadsheetApp.flush();
      return { status: "success", message: `Pedido #${orderId} aprobado por gerencia.` };
    } else {
      return { status: "error", message: `No se encontr贸 el pedido #${orderId}.` };
    }
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: e.toString() };
  }
}


// --- LGICA DE COMANDA RUTAS ---

function showComandaRutasDialog() {
  const html = HtmlService.createHtmlOutputFromFile('ComandaRutasDialog')
    .setWidth(1000)
    .setHeight(700);
  SpreadsheetApp.getUi().showModalDialog(html, 'Comanda Rutas');
}

function getTodaysCommunes() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontr贸 la hoja "Orders".');
  }
  const lastRow = ordersSheet.getLastRow();
  if (lastRow < 2) return [];
  
  const communeRange = ordersSheet.getRange(2, 7, lastRow - 1, 1); // Column G
  const communeValues = communeRange.getValues().flat();
  
  const uniqueCommunes = [...new Set(communeValues)].filter(Boolean);
  return uniqueCommunes.sort();
}

function getOrdersForRouting() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontr贸 la hoja "Orders".');
  }

  const lastRow = ordersSheet.getLastRow();
  if (lastRow < 2) return [];

  // Confirmed Columns: A, B, D, E, F, G, H. Van is O (assumed).
  // A(0): Order #, B(1): Customer, D(3): Phone, E(4): Address, F(5): Dept, G(6): Commune, H(7): Status, O(14): Van
  const dataRange = ordersSheet.getRange(2, 1, lastRow - 1, 15); // Read up to column O for the van
  const values = dataRange.getValues();

  const uniqueOrders = {};
  values.forEach((row, index) => {
    const orderId = row[0];
    if (orderId && !uniqueOrders[orderId]) {
      uniqueOrders[orderId] = {
        orderNumber: orderId,
        customerName: row[1] || '',
        phone: row[3] || '',
        address: row[4] || '',
        department: row[5] || '',
        commune: row[6] || '',
        status: row[7] || '',
        van: row[14] || '' // Just read the historical value
      };
    }
  });

  return Object.values(uniqueOrders);
}

function saveRouteChanges(updatedOrders) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontr贸 la hoja "Orders".');
  }

  // Check if "Furg贸n" column exists, if not, add it at the end.
  const headers = ordersSheet.getRange(1, 1, 1, ordersSheet.getLastColumn()).getValues()[0];
  const vanHeader = 'Furg贸n';
  let vanColumn = headers.indexOf(vanHeader) + 1;
  
  if (vanColumn === 0) { // Not found
    vanColumn = ordersSheet.getLastColumn() + 1;
    ordersSheet.getRange(1, vanColumn).setValue(vanHeader).setFontWeight('bold');
  }

  const allOrderNumbers = ordersSheet.getRange("A2:A" + ordersSheet.getLastRow()).getValues().flat();
  
  updatedOrders.forEach(order => {
    allOrderNumbers.forEach((orderNumber, index) => {
      if (orderNumber === order.orderNumber) {
        const row = index + 2; // +2 because sheet is 1-based and we skipped header
        ordersSheet.getRange(row, 4).setValue(order.phone);       // Col D: Phone
        ordersSheet.getRange(row, 5).setValue(order.address);     // Col E: Address
        ordersSheet.getRange(row, 6).setValue(order.department);  // Col F: Department
        ordersSheet.getRange(row, 7).setValue(order.commune);     // Col G: Commune
        ordersSheet.getRange(row, vanColumn).setValue(order.van);
      }
    });
  });

  return { status: 'success', message: 'Cambios guardados con 茅xito.' };
}

function processRouteXLData(pastedText) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  const lines = pastedText.split('\n');
  const orderedOrderNumbers = lines.map(line => {
    const match = line.match(/#\d+/); // Assumes order numbers are formatted like #1234
    return match ? match[0] : null;
  }).filter(Boolean);

  if (orderedOrderNumbers.length === 0) {
    throw new Error("No se pudieron encontrar n煤meros de pedido v谩lidos (ej: #1234) en el texto pegado.");
  }

  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) throw new Error('No se encontr贸 la hoja "Orders".');
  const ordersData = ordersSheet.getDataRange().getValues();
  const headers = ordersData.shift();

  const ordersMap = {};
  ordersData.forEach(row => {
    const orderNumber = row[0];
    if (!ordersMap[orderNumber]) ordersMap[orderNumber] = [];
    ordersMap[orderNumber].push(row);
  });

  const sortedData = [];
  orderedOrderNumbers.forEach(orderNumber => {
    if (ordersMap[orderNumber]) {
      sortedData.push(...ordersMap[orderNumber]);
    }
  });

  let routeSheet = ss.getSheetByName("Ruta Optimizada");
  if (routeSheet) routeSheet.clear();
  else routeSheet = ss.insertSheet("Ruta Optimizada");

  routeSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  if (sortedData.length > 0) {
    routeSheet.getRange(2, 1, sortedData.length, sortedData[0].length).setValues(sortedData);
  }
  routeSheet.autoResizeColumns(1, headers.length);

  return { status: 'success', message: `Se ha creado la hoja "Ruta Optimizada" con ${orderedOrderNumbers.length} pedidos ordenados.` };
}

function generatePrintableRouteSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const routeSheet = ss.getSheetByName("Ruta Optimizada");
  if (!routeSheet) {
    throw new Error('Primero debe procesar los datos de RouteXL para crear la hoja "Ruta Optimizada".');
  }

  const routeData = routeSheet.getDataRange().getValues();
  routeData.shift(); // remove headers

  // --- 1. Create "Orden de Envasado (Ruta)" ---
  const orderSequence = [];
  const seenOrders = new Set();
  routeData.forEach(row => {
    const orderNumber = row[0]; // Col A
    if (orderNumber && !seenOrders.has(orderNumber)) {
        orderSequence.push(orderNumber);
        seenOrders.add(orderNumber);
    }
  });

  const finalPackagingData = [];
  orderSequence.forEach((orderNumber, index) => {
      routeData.forEach(row => {
          if (row[0] === orderNumber) {
              finalPackagingData.push([
                  index + 1,   // Orden Ruta
                  orderNumber, // N潞 Pedido
                  row[9],      // Producto (Col J)
                  row[10]      // Cantidad (Col K)
              ]);
          }
      });
  });

  let packagingSheet = ss.getSheetByName("Orden de Envasado (Ruta)");
  if (packagingSheet) packagingSheet.clear();
  else packagingSheet = ss.insertSheet("Orden de Envasado (Ruta)");

  const packagingHeaders = ["Orden Ruta", "N潞 Pedido", "Producto", "Cantidad"];
  packagingSheet.getRange("A1:D1").setValues([packagingHeaders]).setFontWeight('bold');
  if (finalPackagingData.length > 0) {
    packagingSheet.getRange(2, 1, finalPackagingData.length, 4).setValues(finalPackagingData);
  }
  packagingSheet.autoResizeColumns(1, 4);

  // --- 2. Create "Orden de Carga (Ruta)" ---
  const loadingData = [];
  orderSequence.forEach((orderNumber, index) => {
      const orderRow = routeData.find(row => row[0] === orderNumber);
      if(orderRow) {
        const address = orderRow[4] || ''; // Col E
        const dept = orderRow[5] || '';    // Col F
        const fullAddress = [address, dept].filter(Boolean).join(', ');
        
        loadingData.push([
          index + 1,        // Orden Carga
          orderNumber,      // N潞 Pedido
          orderRow[1],      // Cliente (Col B)
          fullAddress,      // Direcci贸n Completa
          orderRow[6],      // Comuna (Col G)
          orderRow[14] || ''// Furg贸n (Col O)
        ]);
      }
  });

  let loadingSheet = ss.getSheetByName("Orden de Carga (Ruta)");
  if (loadingSheet) loadingSheet.clear();
  else loadingSheet = ss.insertSheet("Orden de Carga (Ruta)");

  const loadingHeaders = ["Orden Carga", "N潞 Pedido", "Cliente", "Direcci贸n Completa", "Comuna", "Furg贸n"];
  loadingSheet.getRange("A1:F1").setValues([loadingHeaders]).setFontWeight('bold');
  if (loadingData.length > 0) {
    loadingSheet.getRange(2, 1, loadingData.length, 6).setValues(loadingData);
  }
  loadingSheet.autoResizeColumns(1, 6);

  return { status: 'success', message: 'Se han generado las hojas de Envasado y Carga.' };
}


// --- MDULO DE FINANZAS ---

function showImportMovementsDialog() {
  const html = HtmlService.createHtmlOutputFromFile('ImportMovementsDialog')
    .setWidth(600)
    .setHeight(400);
  SpreadsheetApp.getUi().showModalDialog(html, 'Importar Movimientos Bancarios');
}

function importBankMovements(data) {
  if (!data || typeof data !== 'string') {
    throw new Error("No se proporcionaron datos v谩lidos para importar.");
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("MovimientosBancarios");
  if (!sheet) {
    throw new Error("No se encontr贸 la hoja 'MovimientosBancarios'. Por favor, vuelve a abrir el documento para que se cree autom谩ticamente.");
  }

  const newRows = data.trim().split('\n').map(line => line.split('\t'));
  if (newRows.length === 0) {
    return "No se encontraron filas para importar.";
  }

  // 1. Read existing data using a more robust method
  const allData = sheet.getDataRange().getValues();
  const headers = allData.shift(); // Remove header row
  const existingData = allData;   // The rest is existing data

  Logger.log(`Total historical rows read: ${existingData.length}`);

  // DEBUG: Key with Amount and Description
  const existingKeys = new Set(existingData.map(row => 
    `${String(row[0]).trim()}|${String(row[1]).trim()}`
  ));
  
  if (existingKeys.size > 0) {
    Logger.log(`Sample historical key (Amount + Desc): ${existingKeys.values().next().value}`);
  }

  // 3. Filter out duplicates from the new rows
  const rowsToInsert = [];
  let duplicateCount = 0;
  
  newRows.forEach((row, index) => {
    // DEBUG: Key with Amount and Description
    const key = `${String(row[0]).trim()}|${String(row[1]).trim()}`;
    if (index === 0) {
      Logger.log(`Sample new key (Amount + Desc): ${key}`);
      Logger.log(`Does historical set have this new key? ${existingKeys.has(key)}`);
    }
    if (!existingKeys.has(key)) {
      rowsToInsert.push(row);
      existingKeys.add(key); // Add new key to set to avoid duplicate imports in the same batch
    } else {
      duplicateCount++;
    }
  });

  // 4. Insert only the new, non-duplicate rows
  if (rowsToInsert.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, rowsToInsert.length, rowsToInsert[0].length).setValues(rowsToInsert);
  }

  // 5. Update the return message
  let message = `Importaci贸n completada.`;
  if (rowsToInsert.length > 0) {
    message += ` Se a帽adieron ${rowsToInsert.length} nuevos movimientos.`;
  }
  if (duplicateCount > 0) {
    message += ` Se omitieron ${duplicateCount} movimientos duplicados.`;
  }
  if (rowsToInsert.length === 0 && duplicateCount === 0) {
    message = "No se import贸 nada. Revisa los datos pegados.";
  }
  
  return message;
}

function showFinanceDashboard() {
  const html = HtmlService.createHtmlOutputFromFile('FinanceDashboardDialog')
    .setWidth(500)
    .setHeight(350);
  SpreadsheetApp.getUi().showModalDialog(html, 'M贸dulo de Finanzas');
}

function showConciliationDialog() {
  const html = HtmlService.createHtmlOutputFromFile('SalesReconciliationDialog')
    .setWidth(1000)
    .setHeight(700);
  SpreadsheetApp.getUi().showModalDialog(html, 'Conciliar Ingresos de Ventas');
}

function showExpenseConciliationDialog() {
  SpreadsheetApp.getUi().alert("Este m贸dulo (Conciliar Egresos) ser谩 implementado en un pr贸ximo paso.");
}

function getReconciliationData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const movementsSheet = ss.getSheetByName("MovimientosBancarios");
  const ordersSheet = ss.getSheetByName("Orders");
  const clientBankSheet = ss.getSheetByName("ClientBankData");

  if (!movementsSheet || !ordersSheet || !clientBankSheet) {
    throw new Error("Una o m谩s hojas requeridas no se encontraron: MovimientosBancarios, Orders, ClientBankData.");
  }

  // --- 1. Fetch all necessary data ---
  const movementsData = movementsSheet.getDataRange().getValues();
  const ordersData = ordersSheet.getDataRange().getValues();
  const clientBankData = clientBankSheet.getDataRange().getValues();

  // --- 2. Prepare initial lists ---
  const movementsHeaders = movementsData.shift();
  const assignedColIdx = movementsHeaders.indexOf("Asignado a Pedido");
  const chargeColIdx = movementsHeaders.indexOf("CARGO/ABONO");
  const amountColIdx = movementsHeaders.indexOf("MONTO");
  const descColIdx = movementsHeaders.indexOf("DESCRIPCIN MOVIMIENTO");
  const dateColIdx = movementsHeaders.indexOf("FECHA");

  let unassignedPayments = [];
  movementsData.forEach((row, index) => {
    if (row[chargeColIdx] === 'A' && !row[assignedColIdx]) {
      const amount = parseFloat(String(row[amountColIdx]).replace(/[^0-9,-]+/g,"").replace(",", "."));
      if (isNaN(amount) || amount <= 0) return;
      let paymentDate;
      const dateCell = row[dateColIdx];
      if (dateCell instanceof Date) paymentDate = dateCell;
      else if (typeof dateCell === 'string' && dateCell) paymentDate = parseDDMMYYYY(dateCell);
      if (!paymentDate || isNaN(paymentDate.getTime())) return;
      unassignedPayments.push({ amount, desc: row[descColIdx], date: paymentDate, extractedName: extractNameFromDescription(row[descColIdx]), paymentId: `row|${index + 2}` });
    }
  });

  ordersData.shift();
  const REAL_ORDER_ID_COL = 0, REAL_CUSTOMER_NAME_COL = 1, REAL_STATUS_COL = 7, REAL_ORDER_DATE_COL = 8, REAL_TOTAL_AMOUNT_COL = 15, REAL_PAYMENT_METHOD_COL = 18, REAL_PHONE_COL = 3, REAL_RUT_COL = 16;
  const pendingOrdersMap = {};
  ordersData.forEach((row, index) => {
    const orderId = row[REAL_ORDER_ID_COL];
    if (!orderId) return;
    const status = String(row[REAL_STATUS_COL]).trim();
    const method = row[REAL_PAYMENT_METHOD_COL];
    const orderDate = new Date(row[REAL_ORDER_DATE_COL]);
    const isEligible = (method === 'bacs' && (status === 'En Espera de Pago' || status === 'Procesando') && orderDate instanceof Date && !isNaN(orderDate));
    if (isEligible && !pendingOrdersMap[orderId]) {
       const totalAmount = parseFloat(String(row[REAL_TOTAL_AMOUNT_COL]).replace(/[^0-9,-]+/g,"").replace(",","."));
       if (isNaN(totalAmount) || totalAmount <= 0) return;
       pendingOrdersMap[orderId] = { orderId, customerName: row[REAL_CUSTOMER_NAME_COL], phone: row[REAL_PHONE_COL], normalizedPhone: normalizePhoneNumber(row[REAL_PHONE_COL]), totalAmount, date: orderDate, status, rowNumber: index + 2, customerRUT: row[REAL_RUT_COL] };
    }
  });
  let pendingOrders = Object.values(pendingOrdersMap);

  // --- 3. Matching Logic ---
  const historicalSuggestions = [], highConfidenceSuggestions = [], lowConfidenceSuggestions = [];
  const matchedPaymentIds = new Set(), matchedOrderIds = new Set();
  
  const clientBankMap = new Map(clientBankData.slice(1).map(row => [row[0], row[1]]));

  // Tier 1: Historical Matching
  unassignedPayments.forEach(payment => {
    const paymentIdentifier = payment.extractedName;
    const customerRUT = clientBankMap.get(paymentIdentifier);
    if (customerRUT) {
      const order = pendingOrders.find(o => o.customerRUT === customerRUT && !matchedOrderIds.has(o.orderId));
      if (order) {
        historicalSuggestions.push({ payment, order });
        matchedPaymentIds.add(payment.paymentId);
        matchedOrderIds.add(order.orderId);
      }
    }
  });

  // Tiers 2 & 3: Score-Based Matching
  unassignedPayments.filter(p => !matchedPaymentIds.has(p.paymentId)).forEach(payment => {
    let bestMatch = { order: null, score: 0, amountScore: 0, nameScore: 0, dateScore: 0 };
    pendingOrders.filter(o => !matchedOrderIds.has(o.orderId)).forEach(order => {
      if (payment.date < new Date(order.date.getTime() - 24*60*60*1000)) return;
      const amountDiff = Math.abs(payment.amount - order.totalAmount);
      let amountScore = 0;
      if (amountDiff === 0) amountScore = 100;
      else if (amountDiff < 5000) amountScore = 100 - (amountDiff / 50);
      else return; 
      const msPerDay = 1000 * 60 * 60 * 24;
      const dayDifference = Math.floor((new Date(payment.date.getFullYear(), payment.date.getMonth(), payment.date.getDate()) - new Date(order.date.getFullYear(), order.date.getMonth(), order.date.getDate())) / msPerDay);
      if (dayDifference < 0) return; 
      const dateScore = Math.max(0, 100 - (dayDifference * 10));
      if (dateScore <= 0 && dayDifference > 0) return;
      const nameScore = calculateNameSimilarity(payment.extractedName, order.customerName);
      if (nameScore < 20) return;
      const totalScore = (amountScore * 0.5) + (nameScore * 0.3) + (dateScore * 0.2);
      if (totalScore > bestMatch.score) bestMatch = { order, score: totalScore, amountScore, nameScore, dateScore };
    });

    if (bestMatch.order && bestMatch.score > 65) {
      const suggestion = { payment, order: bestMatch.order, score: Math.round(bestMatch.score), amountScore: Math.round(bestMatch.amountScore), nameScore: Math.round(bestMatch.nameScore), dateScore: Math.round(bestMatch.dateScore) };
      if (bestMatch.amountScore === 100) highConfidenceSuggestions.push(suggestion);
      else lowConfidenceSuggestions.push(suggestion);
      matchedPaymentIds.add(payment.paymentId);
      matchedOrderIds.add(bestMatch.order.orderId);
    }
  });

  // --- 4. Prepare return data ---
  const formatDate = (date) => (date instanceof Date && !isNaN(date)) ? Utilities.formatDate(date, Session.getScriptTimeZone(), "dd/MM/yyyy") : "Fecha Inv谩lida";
  const formatSuggestion = s => ({ ...s, payment: { ...s.payment, date: formatDate(s.payment.date) }, order: { ...s.order, date: formatDate(s.order.date) } });

  const manualListOrders = pendingOrders.filter(o => o.status === 'En Espera de Pago');

  return {
    historicalSuggestions: historicalSuggestions.map(formatSuggestion),
    highConfidenceSuggestions: highConfidenceSuggestions.map(formatSuggestion),
    lowConfidenceSuggestions: lowConfidenceSuggestions.map(formatSuggestion),
    unmatchedPayments: unassignedPayments.map(p => ({ ...p, date: formatDate(p.date) })),
    manualListOrders: manualListOrders.map(o => ({ ...o, date: formatDate(o.date) }))
  };
}


// --- LGICA DEL DASHBOARD ---

function showDashboard() {
  updateAcquisitionListAutomated(); // Actualiza la lista de adquisiciones autom谩ticamente
  const html = HtmlService.createHtmlOutputFromFile('DashboardDialog')
    .setWidth(1200)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'Dashboard de Operaciones');
}

function startDashboardRefresh() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  if (!ordersSheet) {
    throw new Error('No se encontr贸 la hoja "Orders".');
  }
  const orderData = ordersSheet.getRange("A2:B" + ordersSheet.getLastRow()).getValues();
  const customerOrders = {};
  orderData.forEach(([orderNumber, customerName]) => {
    if (customerName) {
      if (!customerOrders[customerName]) customerOrders[customerName] = new Set();
      customerOrders[customerName].add(orderNumber);
    }
  });
  const duplicates = {};
  for (const customer in customerOrders) {
    if (customerOrders[customer].size > 1) {
      duplicates[customer] = Array.from(customerOrders[customer]);
    }
  }
  if (Object.keys(duplicates).length > 0) {
    showDuplicateDialog(duplicates);
  } else {
    checkForNewSuppliers();
  }
}

function showDuplicateDialog(duplicateData) {
  const template = HtmlService.createTemplateFromFile('DuplicateDialog');
  template.duplicates = JSON.stringify(duplicateData);
  const html = template.evaluate().setWidth(700).setHeight(500);
  SpreadsheetApp.getUi().showModalDialog(html, 'Resolver Pedidos Duplicados');
}

function deleteOrdersByNumber(orderNumbersToDelete) {
  if (!orderNumbersToDelete || orderNumbersToDelete.length === 0) return "No se seleccion贸 ning煤n pedido para eliminar.";
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Orders');
  const data = sheet.getDataRange().getValues();
  const rowsToDelete = [];
  for (let i = data.length - 1; i >= 1; i--) {
    if (orderNumbersToDelete.includes(String(data[i][0]))) {
      rowsToDelete.push(i + 1);
    }
  }
  if (rowsToDelete.length > 0) {
    rowsToDelete.forEach(rowNum => sheet.deleteRow(rowNum));
    checkForNewSuppliers();
    return `Se eliminaron ${rowsToDelete.length} filas. Continuando con el chequeo de proveedores...`;
  } else {
    return "No se encontraron los pedidos seleccionados.";
  }
}

function checkForNewSuppliers() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const skuSheet = ss.getSheetByName("SKU");
  const proveedoresSheet = ss.getSheetByName("Proveedores");
  if (!skuSheet || !proveedoresSheet) {
    SpreadsheetApp.getUi().alert("Faltan las hojas 'SKU' o 'Proveedores'.");
    return;
  }
  const skuSuppliers = new Set(skuSheet.getRange("I2:I" + skuSheet.getLastRow()).getValues().flat().filter(String));
  const existingSuppliers = new Set(proveedoresSheet.getRange("A2:A" + proveedoresSheet.getLastRow()).getValues().flat().filter(String));
  const newSuppliers = [...skuSuppliers].filter(s => !existingSuppliers.has(s));
  if (newSuppliers.length > 0) {
    showNewSupplierDialog(newSuppliers);
  } else {
    SpreadsheetApp.getUi().alert("Todos los datos est谩n limpios y consistentes. Ahora puedes cargar las m茅tricas en el dashboard.");
  }
}

function showNewSupplierDialog(newSuppliers) {
  const template = HtmlService.createTemplateFromFile('NewSupplierDialog');
  template.newSuppliers = JSON.stringify(newSuppliers);
  const html = template.evaluate().setWidth(600).setHeight(400);
  SpreadsheetApp.getUi().showModalDialog(html, 'A帽adir Tel茅fonos de Proveedores Nuevos');
}

function saveNewSuppliers(supplierData) {
  const proveedoresSheet = ss.getSheetByName("Proveedores");
  const dataToAppend = Object.entries(supplierData);
  if (dataToAppend.length > 0) {
    proveedoresSheet.getRange(proveedoresSheet.getLastRow() + 1, 1, dataToAppend.length, 2).setValues(dataToAppend);
  }
  SpreadsheetApp.getUi().alert("Proveedores guardados. Ya puedes cargar las m茅tricas en el dashboard.");
}

// --- FUNCIONES PBLICAS PARA EL DASHBOARD ---

function getDashboardSummaryMetrics() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');

    // --- L贸gica de costos duplicada para independencia ---
    const costosSheet = ss.getSheetByName('CostosVenta');
    const productCostMap = {};
    if (costosSheet && costosSheet.getLastRow() > 1) {
      const costosData = costosSheet.getRange("B2:C" + costosSheet.getLastRow()).getValues();
      for (let i = costosData.length - 1; i >= 0; i--) {
        const row = costosData[i];
        const productName = row[0];
        const cost = parseFloat(row[1]);
        if (productName && !productCostMap[productName] && !isNaN(cost)) {
          productCostMap[productName] = cost;
        }
      }
    }
    // --- Fin de l贸gica duplicada ---

    let totalSales = 0;
    let totalCosts = 0;
    const orderIds = new Set();

    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("A2:M" + ordersSheet.getLastRow()).getValues();
        ordersData.forEach(row => {
            const orderId = row[0];
            const productName = row[9]; // Columna J: Nombre Producto
            const quantity = row[10];
            const lineTotal = row[12];

            if (orderId) orderIds.add(orderId);
            if (lineTotal) totalSales += parseFloat(lineTotal) || 0;

            if (productName && quantity && productCostMap[productName]) {
                totalCosts += productCostMap[productName] * (parseInt(quantity, 10) || 0);
            }
        });
    }

    const grossMargin = totalSales - totalCosts;
    const marginPercentage = totalSales > 0 ? (grossMargin / totalSales) * 100 : 0;

    return {
      totalSales: totalSales,
      orderCount: orderIds.size,
      grossMargin: grossMargin,
      marginPercentage: marginPercentage
    };
  } catch (e) {
    Logger.log(`ERROR en getDashboardSummaryMetrics: ${e.stack}`);
    return { error: `Error en M茅tricas de Resumen: ${e.message}` };
  }
}

function getDashboardCostMetrics() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const costosSheet = ss.getSheetByName('CostosVenta');

    const productCostMap = {};
    if (costosSheet && costosSheet.getLastRow() > 1) {
      const costosData = costosSheet.getRange("B2:C" + costosSheet.getLastRow()).getValues();
      for (let i = costosData.length - 1; i >= 0; i--) {
        const row = costosData[i];
        const productName = row[0];
        const cost = parseFloat(row[1]);
        if (productName && !productCostMap[productName] && !isNaN(cost)) {
          productCostMap[productName] = cost;
        }
      }
    }

    let totalCosts = 0;
    const productsWithoutCost = new Set();
    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("A2:K" + ordersSheet.getLastRow()).getValues();
        ordersData.forEach(row => {
            const productName = row[9]; // Columna J: Nombre Producto
            const quantity = row[10];   // Columna K
            if (productName && quantity) {
                if (productCostMap[productName]) {
                    totalCosts += productCostMap[productName] * (parseInt(quantity, 10) || 0);
                } else {
                    productsWithoutCost.add(productName);
                }
            }
        });
    }

    return {
      totalCosts: totalCosts,
      productsWithoutCostCount: productsWithoutCost.size,
      productsWithoutCostNames: Array.from(productsWithoutCost)
    };
  } catch (e) {
    Logger.log(`ERROR en getDashboardCostMetrics: ${e.stack}`);
    return { error: `Error en M茅tricas de Costos: ${e.message}` };
  }
}

function getDashboardTopProducts() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const productQuantities = {};

    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("J2:K" + ordersSheet.getLastRow()).getValues(); // Leer desde la columna J
        ordersData.forEach(row => {
            const productName = row[0]; // J es index 0 en este rango
            const quantity = row[1];    // K es index 1 en este rango
            if (productName && quantity) {
                productQuantities[productName] = (productQuantities[productName] || 0) + (parseInt(quantity, 10) || 0);
            }
        });
    }

    const topSoldProducts = Object.entries(productQuantities).sort(([, a], [, b]) => b - a).slice(0, 5);
    return topSoldProducts;
  } catch (e) {
    Logger.log(`ERROR en getDashboardTopProducts: ${e.stack}`);
    return { error: `Error en Top Productos: ${e.message}` };
  }
}

function getDashboardCommuneDistribution() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const communeCounts = {};

    if (ordersSheet && ordersSheet.getLastRow() > 1) {
        const ordersData = ordersSheet.getRange("A2:G" + ordersSheet.getLastRow()).getValues();
        ordersData.forEach(row => {
            const orderId = row[0];     // A es index 0
            const commune = row[6];     // G es index 6
            if (commune) {
                const orderKey = `${orderId}-${commune}`;
                if (!communeCounts[orderKey]) {
                    communeCounts[orderKey] = commune;
                }
            }
        });
    }

    const communeTally = {};
    Object.values(communeCounts).forEach(c => communeTally[c] = (communeTally[c] || 0) + 1);
    const communeDistribution = Object.entries(communeTally).sort(([, a], [, b]) => b - a);
    return communeDistribution;
  } catch (e) {
    Logger.log(`ERROR en getDashboardCommuneDistribution: ${e.stack}`);
    return { error: `Error en Distribuci贸n por Comuna: ${e.message}` };
  }
}


function futureModulePlaceholder() {
  SpreadsheetApp.getUi().alert("Este m贸dulo ser谩 implementado en una futura actualizaci贸n.");
}

// --- FLUJO DE ENVASADO ---

function startPackagingProcess() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  if (!ordersSheet || !skuSheet) {
    SpreadsheetApp.getUi().alert('Error: Faltan las hojas "Orders" o "SKU".');
    return;
  }
  const newProducts = getNewProducts(ordersSheet, skuSheet);
  if (newProducts.length > 0) {
    showBatchUpdateDialog(newProducts);
  } else {
    showCategorySelectionDialog();
  }
}

function showBatchUpdateDialog(productList) {
  const template = HtmlService.createTemplateFromFile('Dialog');
  template.productList = JSON.stringify(productList);
  const html = template.evaluate().setWidth(800).setHeight(600);
  SpreadsheetApp.getUi().showModalDialog(html, 'Paso 1: A帽adir Nuevos Productos a SKU');
}

function saveSkuData(data) {
  const skuSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('SKU');
  skuSheet.appendRow([data.nombreProducto, data.productoBase, data.formato, data.cantidad, data.unidad, data.categoria, data.cantidadVenta, data.unidadVenta, '']);
  return { status: 'success' };
}

function triggerCategoryDialog() {
  showCategorySelectionDialog();
}

function showCategorySelectionDialog() {
  const html = HtmlService.createHtmlOutputFromFile('CategoryDialog').setWidth(500).setHeight(450);
  SpreadsheetApp.getUi().showModalDialog(html, 'Paso 2: Seleccionar Categor铆as para Envasado');
}

function getPackagingData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  const skuMap = getSkuMap(skuSheet);
  const orderData = ordersSheet.getRange("J2:K" + ordersSheet.getLastRow()).getValues();
  const productTotals = {};
  orderData.forEach(([name, qty]) => {
    if (name && qty) {
      if (!productTotals[name]) { productTotals[name] = 0; }
      productTotals[name] += parseInt(qty, 10) || 0;
    }
  });
  const categorySummary = {};
  for (const productName in productTotals) {
    const category = skuMap[productName] ? skuMap[productName].category : 'Sin Categor铆a';
    if (!categorySummary[category]) { categorySummary[category] = { count: 0, products: {} }; }
    categorySummary[category].count++;
    categorySummary[category].products[productName] = productTotals[productName];
  }
  return categorySummary;
}

function generatePackagingSheet(selectedCategories) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const data = getPackagingData();
  let sheet = ss.getSheetByName("Lista de Envasado");
  if (sheet) { sheet.clear(); } else { sheet = ss.insertSheet("Lista de Envasado"); }
  let currentRow = 1;
  sheet.getRange("A1:C1").setValues([["Cantidad", "Inventario", "Nombre Producto"]]).setFontWeight("bold");
  selectedCategories.sort().forEach(category => {
    currentRow++;
    sheet.getRange(currentRow, 1, 1, 3).merge().setValue(category.toUpperCase()).setFontWeight("bold").setHorizontalAlignment("center").setBackground("#f2f2f2");
    currentRow++;
    const products = data[category].products;
    const sortedProductNames = Object.keys(products).sort();
    sortedProductNames.forEach(productName => {
      sheet.getRange(currentRow, 1).setValue(products[productName]);
      sheet.getRange(currentRow, 3).setValue(productName);
      currentRow++;
    });
  });
  sheet.autoResizeColumns(1, 3);
  const printUrl = `https://docs.google.com/spreadsheets/d/${ss.getId()}/export?format=pdf&gid=${sheet.getSheetId()}&portrait=true&fitw=true&gridlines=false&printtitle=false`;
  return printUrl;
}

// --- FLUJO DE ADQUISICIONES ---

/**
 * Genera y guarda autom谩ticamente la lista de adquisiciones.
 * Calcula las necesidades basadas en los pedidos y SKU, y luego guarda el plan.
 */
function updateAcquisitionListAutomated() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName('Orders');
    const skuSheet = ss.getSheetByName('SKU');

    if (!ordersSheet || !skuSheet) {
      Logger.log('Omitiendo actualizaci贸n autom谩tica de adquisiciones: Faltan las hojas "Orders" o "SKU".');
      return;
    }

    // 1. Generar el plan de adquisiciones
    const { productToSkuMap, baseProductPurchaseOptions } = getPurchaseDataMaps(skuSheet);
    const baseProductNeeds = calculateBaseProductNeeds(ordersSheet, productToSkuMap);
    const acquisitionPlan = createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions);

    // 2. Transformar el plan al formato que espera `saveAcquisitions`
    const finalPlan = Object.values(acquisitionPlan).map(p => {
      const suggestedFormatString = `${p.suggestedFormat.name} (${p.suggestedFormat.size} ${p.suggestedFormat.unit})`;
      const allFormatStrings = p.availableFormats.map(f => `${f.name} (${f.size} ${f.unit})`);

      return {
        productName: p.productName,
        quantity: p.suggestedQty,
        selectedFormatString: suggestedFormatString,
        supplier: p.supplier,
        totalNeed: p.totalNeed,
        unit: p.unit,
        allFormatStrings: allFormatStrings,
        allFormatObjects: p.availableFormats.map(f => ({...f}))
      };
    });

    // 3. Guardar el plan utilizando la funci贸n existente
    // Esta funci贸n ya se encarga de limpiar la hoja, escribir encabezados y obtener el inventario actual.
    saveAcquisitions(finalPlan);
    Logger.log("La lista de adquisiciones se ha actualizado autom谩ticamente.");

  } catch (e) {
    Logger.log(`Error durante la actualizaci贸n autom谩tica de adquisiciones: ${e.toString()}`);
    // No mostramos una alerta al usuario para no ser intrusivos, pero lo registramos.
  }
}

function getAcquisitionDataForEditor() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  const proveedoresSheet = ss.getSheetByName('Proveedores');

  if (!ordersSheet || !skuSheet || !proveedoresSheet) {
    throw new Error('Faltan una o m谩s hojas requeridas: "Orders", "SKU", o "Proveedores".');
  }

  // 1. Generar el plan de adquisiciones (l贸gica reutilizada)
  const { productToSkuMap, baseProductPurchaseOptions } = getPurchaseDataMaps(skuSheet);
  const baseProductNeeds = calculateBaseProductNeeds(ordersSheet, productToSkuMap);
  const acquisitionPlan = createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions);

  // 2. Obtener la lista de proveedores
  const supplierData = proveedoresSheet.getRange("A2:A" + proveedoresSheet.getLastRow()).getValues().flat().filter(String);
  const supplierSet = new Set(supplierData);
  supplierSet.add("Patio Mayorista"); // Asegurarse de que "Patio Mayorista" est茅 disponible

  // Convertir el plan de un objeto a un array para que sea m谩s f谩cil de manejar en el lado del cliente
  const planAsArray = Object.values(acquisitionPlan);

  return {
    acquisitionPlan: planAsArray,
    allSuppliers: Array.from(supplierSet).sort()
  };
}

function showAcquisitionEditor() {
  const dataForEditor = getAcquisitionDataForEditor();
  const template = HtmlService.createTemplateFromFile('AcquisitionEditorDialog');
  // Pasar el objeto de datos directamente al template. La serializaci贸n se har谩 en el lado del cliente.
  template.data = dataForEditor;
  const html = template.evaluate().setWidth(1100).setHeight(700);
  SpreadsheetApp.getUi().showModalDialog(html, 'Editar Borrador de Adquisiciones');
}

function saveAcquisitions(finalPlan) {
  // finalPlan es un array de objetos desde el cliente.
  // Cada objeto: { productName, quantity, selectedFormatString, supplier, totalNeed, unit, allFormatStrings, allFormatObjects }
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName("Lista de Adquisiciones");
  if (sheet) {
    sheet.clear();
    sheet.clearConditionalFormatRules();
  } else {
    sheet = ss.insertSheet("Lista de Adquisiciones");
  }

  // Escribir datos en un formato plano para mayor robustez, con una columna de proveedor.
  const headers = ["Producto Base", "Cantidad a Comprar", "Formato de Compra", "Inventario Actual", "Unidad Inventario Actual", "Necesidad de Venta", "Unidad Venta", "Inventario al Finalizar", "Unidad Inventario Final", "Precio Adq. Anterior", "Precio Adq. HOY", "Proveedor"];
  sheet.getRange("A1:L1").setValues([headers]).setFontWeight("bold");
  sheet.getRange("A1:C1").setBackground("#d9ead3");
  sheet.getRange("D1:E1").setBackground("#fff2cc");
  sheet.getRange("F1:K1").setBackground("#f4cccc");
  sheet.getRange("L1").setBackground("#d9d9d9");
  sheet.setFrozenRows(1);

  const inventoryMap = getCurrentInventory(); // Get current inventory
  const priceMap = getHistoricalPrices(); // Get historical prices
  const dataToWrite = [];

  finalPlan.forEach(p => {
    const selectedFormatObject = p.allFormatObjects.find(f => `${f.name} (${f.size} ${f.unit})` === p.selectedFormatString);
    const formatSize = selectedFormatObject ? selectedFormatObject.size : 0;

    const currentInventory = inventoryMap[p.productName] || { quantity: 0, unit: p.unit };

    const purchasedAmount = (parseFloat(p.quantity) || 0) * formatSize;
    const finalInventory = currentInventory.quantity + purchasedAmount - (parseFloat(p.totalNeed) || 0);

    const history = priceMap[p.productName] || [];
    const precioHoy = history.length > 0 ? history[0].price : "";
    const precioAnterior = history.length > 1 ? history[1].price : "";

    const rowData = [
      p.productName,
      p.quantity,
      p.selectedFormatString,
      currentInventory.quantity, // Use actual inventory
      currentInventory.unit,     // Use actual inventory unit
      p.totalNeed,
      p.unit,
      finalInventory,
      p.unit,
      precioAnterior, // Columna J
      precioHoy,      // Columna K
      p.supplier || "Sin Proveedor"
    ];
    dataToWrite.push(rowData);
  });

  if (dataToWrite.length > 0) {
    sheet.getRange(2, 1, dataToWrite.length, headers.length).setValues(dataToWrite);

    // Aplicar la validaci贸n de datos a toda la columna de formato de una vez
    const formatColumnRange = sheet.getRange("C2:C" + (dataToWrite.length + 1));
    // Nota: Esta validaci贸n ser谩 la misma para todas las celdas (la del 煤ltimo producto).
    // Una validaci贸n por celda es necesaria si los formatos var铆an mucho.
    finalPlan.forEach((p, index) => {
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(p.allFormatStrings).build();
      sheet.getRange(index + 2, 3).setDataValidation(rule);
    });
  }

  sheet.autoResizeColumns(1, headers.length);

  return { status: "success", message: "Lista de adquisiciones guardada con 茅xito." };
}

function generateAcquisitionDRAFT() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName('Orders');
  const skuSheet = ss.getSheetByName('SKU');
  if (!ordersSheet || !skuSheet) {
    SpreadsheetApp.getUi().alert('Faltan las hojas "Orders" o "SKU".');
    return;
  }
  const { productToSkuMap, baseProductPurchaseOptions } = getPurchaseDataMaps(skuSheet);
  const baseProductNeeds = calculateBaseProductNeeds(ordersSheet, productToSkuMap);
  const acquisitionPlan = createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions);
  let sheet = ss.getSheetByName("Lista de Adquisiciones");
  if (sheet) {
    sheet.clear();
    sheet.clearConditionalFormatRules();
  } else {
    sheet = ss.insertSheet("Lista de Adquisiciones");
  }
  const headers = ["Producto Base", "Cantidad a Comprar", "Formato de Compra", "Inventario Actual", "Unidad Inventario Actual", "Necesidad de Venta", "Unidad Venta", "Inventario al Finalizar", "Unidad Inventario Final", "Precio Adq. Anterior", "Precio Adq. HOY"];
  sheet.getRange("A1:K1").setValues([headers]).setFontWeight("bold");
  sheet.getRange("A1:C1").setBackground("#d9ead3");
  sheet.getRange("D1:E1").setBackground("#fff2cc");
  sheet.getRange("F1:K1").setBackground("#f4cccc");
  sheet.setFrozenRows(1);
  const dataBySupplier = groupPlanBySupplier(acquisitionPlan);
  let currentRow = 2;
  const sortedSuppliers = Object.keys(dataBySupplier).sort();
  sortedSuppliers.forEach(supplier => {
    sheet.getRange(currentRow, 1, 1, headers.length).merge().setValue(supplier).setFontWeight("bold").setHorizontalAlignment("center").setBackground("#d9d9d9");
    currentRow++;
    const products = dataBySupplier[supplier];
    products.forEach(p => {
      const suggestedFormatString = `${p.suggestedFormat.name} (${p.suggestedFormat.size} ${p.suggestedFormat.unit})`;
      const totalComprado = p.suggestedQty * p.suggestedFormat.size;
      const inventarioFinal = 0 + totalComprado - p.totalNeed;
      sheet.getRange(currentRow, 1, 1, headers.length).setValues([[p.productName, p.suggestedQty, suggestedFormatString, 0, p.unit, p.totalNeed, p.saleUnit, inventarioFinal, p.unit, "", ""]]);
      const formatOptions = p.availableFormats.map(f => `${f.name} (${f.size} ${f.unit})`);
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(formatOptions).build();
      sheet.getRange(currentRow, 3).setDataValidation(rule);
      currentRow++;
    });
  });
  sheet.autoResizeColumns(1, headers.length);
  SpreadsheetApp.getUi().alert("Borrador de 'Lista de Adquisiciones' generado con 茅xito.");
}

function recalculateRowInventory(sheet, row) {
  const dataRange = sheet.getRange(`A${row}:H${row}`);
  const values = dataRange.getValues()[0];
  const [productoBase, cantidadAComprar, formatoDeCompra, inventarioActual, unidadInvActual, necesidadDeVenta, unidadVenta] = values;
  const multiplierMatch = String(formatoDeCompra).match(/\((\d+(\.\d+)?)/);
  const multiplier = multiplierMatch ? parseFloat(multiplierMatch[1]) : 0;
  const totalComprado = (parseFloat(String(cantidadAComprar).replace(",", ".")) || 0) * multiplier;
  const inventarioFinal = (parseFloat(String(inventarioActual).replace(",", ".")) || 0) + totalComprado - (parseFloat(String(necesidadDeVenta).replace(",", ".")) || 0);
  sheet.getRange(row, 8).setValue(inventarioFinal);
}

function startNotificationProcess() {
  const html = HtmlService.createHtmlOutputFromFile('NotificationDialog').setWidth(600).setHeight(400);
  SpreadsheetApp.getUi().showModalDialog(html, 'Panel de Notificaci贸n a Proveedores');
}

function getSupplierList() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const acquisitionsSheet = ss.getSheetByName("Lista de Adquisiciones");
  if (!acquisitionsSheet || acquisitionsSheet.getLastRow() < 2) {
    return [];
  }
  const supplierData = acquisitionsSheet.getRange("L2:L" + acquisitionsSheet.getLastRow()).getValues();
  const suppliers = new Set();
  supplierData.forEach(row => {
    if (row[0]) {
      suppliers.add(String(row[0]).trim());
    }
  });
  return Array.from(suppliers).sort();
}

function getOrdersForSupplier(supplierName) {
  if (!supplierName) {
    throw new Error("Se requiere un nombre de proveedor.");
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const acquisitionsSheet = ss.getSheetByName("Lista de Adquisiciones");
  const proveedoresSheet = ss.getSheetByName("Proveedores");
  const skuSheet = ss.getSheetByName("SKU");

  if (!acquisitionsSheet) throw new Error("No se encuentra la hoja 'Lista de Adquisiciones'.");
  if (!proveedoresSheet) throw new Error("No se encuentra la hoja 'Proveedores'.");
  if (!skuSheet) throw new Error("No se encuentra la hoja 'SKU'.");

  const phoneMapProveedores = new Map();
  if (proveedoresSheet.getLastRow() > 1) {
    const phoneData = proveedoresSheet.getRange("A2:B" + proveedoresSheet.getLastRow()).getValues();
    phoneData.forEach(([name, phone]) => {
      if (name && phone) phoneMapProveedores.set(String(name).trim(), String(phone).trim());
    });
  }
  const phoneMapSku = new Map();
  if (skuSheet.getLastRow() > 1) {
    const skuSupplierData = skuSheet.getRange("I2:J" + skuSheet.getLastRow()).getValues();
    skuSupplierData.forEach(([supplier, phone]) => {
      if (supplier && phone) {
        const supName = String(supplier).trim();
        if (!phoneMapSku.has(supName)) phoneMapSku.set(supName, String(phone).trim());
      }
    });
  }
  const phone = phoneMapProveedores.get(supplierName) || phoneMapSku.get(supplierName) || 'No encontrado';

  const orders = [];
  if (acquisitionsSheet.getLastRow() > 1) {
    const allData = acquisitionsSheet.getRange("A2:L" + acquisitionsSheet.getLastRow()).getValues();
    allData.forEach(row => {
      const [product, quantity, format, , , , , , , , , supplier] = row;
      if (supplier && String(supplier).trim() === supplierName) {
        if (product && quantity && parseFloat(String(quantity).replace(',', '.')) !== 0) {
          orders.push({
            product: String(product).trim(),
            quantity: quantity,
            format: String(format).trim()
          });
        }
      }
    });
  }

  return {
    phone: phone,
    orders: orders
  };
}

// --- MDULO DE ANLISIS DE PRECIOS ---

/**
 * Procesa la hoja "Reporte Adquisiciones" para registrar las compras diarias
 * en la hoja "Historico Adquisiciones", evitando duplicados.
 * Aplica la l贸gica de correcci贸n de compras si los datos correspondientes est谩n presentes.
 */
function procesarReporteAdquisiciones() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  const reporteSheet = ss.getSheetByName("Reporte Adquisiciones");
  if (!reporteSheet) {
    ui.alert('Error: No se encontr贸 la hoja "Reporte Adquisiciones". Por favor, aseg煤rese de que la hoja exista y tenga ese nombre exacto.');
    return;
  }

  const historicoSheet = ss.getSheetByName("Historico Adquisiciones");
  if (!historicoSheet) {
    ui.alert('Error: No se encontr贸 la hoja "Historico Adquisiciones". Por favor, ejecute el setup inicial desde el men煤.');
    return;
  }

  try {
    const reporteData = reporteSheet.getDataRange().getValues();
    reporteData.shift(); // Quitar encabezados

    const historicoLastRow = historicoSheet.getLastRow();
    const existingIds = new Set();
    if (historicoLastRow > 1) {
      const historicoIds = historicoSheet.getRange(2, 1, historicoLastRow - 1, 1).getValues();
      historicoIds.forEach(row => {
        if (row[0]) existingIds.add(row[0].toString().trim());
      });
    }

    const newRowsToAppend = [];
    const today = new Date();

    reporteData.forEach(row => {
      // Mapeo de columnas (铆ndice basado en 0)
      const ID_COL = 12;
      const ID = row[ID_COL] ? row[ID_COL].toString().trim() : null;

      if (!ID || ID === "" || existingIds.has(ID)) {
        return; // Omitir si no hay ID, est谩 vac铆o o ya fue procesado
      }

      const PRODUCTO_BASE_COL = 1;
      const FORMATO_COMPRA_COL = 2;
      const CANTIDAD_COMPRA_COL = 3;
      const PRECIO_COMPRA_COL = 4;
      const TOTAL_COL = 5;
      const PROVEEDOR_COL = 6;

      const CORRECCION_CANTIDAD_COL = 8;
      const CORRECCION_FORMATO_COL = 9;
      const CORRECCION_FORMATO_CANT_COL = 10;
      const CORRECCION_FORMATO_UNIDAD_COL = 11;

      let cantidadReal, formatoReal, unidadReal;

      // L贸gica de correcci贸n
      if (row[CORRECCION_CANTIDAD_COL] && row[CORRECCION_CANTIDAD_COL] !== "") {
        cantidadReal = row[CORRECCION_CANTIDAD_COL];
        const formatoNombre = row[CORRECCION_FORMATO_COL] || '';
        const formatoCantidad = row[CORRECCION_FORMATO_CANT_COL] || '';
        const formatoUnidad = row[CORRECCION_FORMATO_UNIDAD_COL] || '';
        formatoReal = `${formatoNombre.toString().trim()} (${formatoCantidad} ${formatoUnidad.toString().trim()})`;
        unidadReal = formatoUnidad.toString().trim();
      } else {
        cantidadReal = row[CANTIDAD_COMPRA_COL];
        formatoReal = row[FORMATO_COMPRA_COL];
        const match = formatoReal.toString().match(/\((?:[\d.,]+|\s)*([a-zA-Z谩茅铆贸煤帽]+)\)/);
        unidadReal = match && match[1] ? match[1] : 'Unidad'; // Fallback a "Unidad"
      }

      const newRow = [
        ID,                               // ID
        today,                            // Fecha de Registro
        row[PRODUCTO_BASE_COL],           // Producto Base
        formatoReal,                      // Formato de Compra Real
        cantidadReal,                     // Cantidad Real
        normalizeUnit(unidadReal),        // Unidad Real (usando helper existente)
        row[PRECIO_COMPRA_COL],           // Precio Unitario
        row[TOTAL_COL],                   // Costo Total Real
        row[PROVEEDOR_COL]                // Proveedor
      ];

      newRowsToAppend.push(newRow);
      existingIds.add(ID); // A帽adir al set para evitar duplicados en la misma ejecuci贸n
    });

    if (newRowsToAppend.length > 0) {
      historicoSheet.getRange(historicoSheet.getLastRow() + 1, 1, newRowsToAppend.length, newRowsToAppend[0].length).setValues(newRowsToAppend);
      ui.alert(`Proceso completado. Se han a帽adido ${newRowsToAppend.length} nuevas adquisiciones al historial.`);
    } else {
      ui.alert('No se encontraron nuevas adquisiciones para procesar.');
    }

  } catch (e) {
    Logger.log(e);
    ui.alert(`Ha ocurrido un error durante el procesamiento: ${e.message}`);
  }
}

/**
 * Orquesta el proceso completo de an谩lisis de precios,
 * llamando primero al procesamiento de adquisiciones y luego al c谩lculo de costos.
 */
function runPriceAnalysis() {
  try {
    procesarReporteAdquisiciones();
    const analysisData = getAnalysisData();
    showPriceApprovalDashboard(analysisData);
  } catch (e) {
    Logger.log(e);
    SpreadsheetApp.getUi().alert("Ocurri贸 un error en el proceso de an谩lisis: " + e.message);
  }
}

/**
 * Analiza las adquisiciones del d铆a, calcula los costos de venta y detecta anomal铆as.
 * @returns {{allCosts: Array<Array<any>>, anomalies: Array<object>}} Un objeto que contiene todos los costos calculados y una lista de anomal铆as detectadas.
 */
function getAnalysisData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const DEVIATION_THRESHOLD = 2.5;

  const historicoSheet = ss.getSheetByName("Historico Adquisiciones");
  const skuSheet = ss.getSheetByName("SKU");
  const costosSheet = ss.getSheetByName("CostosVenta");
  const ordersSheet = ss.getSheetByName("Orders");

  if (!historicoSheet || !skuSheet || !costosSheet || !ordersSheet) {
    throw new Error("Faltan una o m谩s hojas requeridas. Ejecute el setup inicial.");
  }

  const historicoData = historicoSheet.getDataRange().getValues();
  const skuData = skuSheet.getDataRange().getValues();
  const costosData = costosSheet.getDataRange().getValues();
  const ordersData = ordersSheet.getDataRange().getValues();

  historicoData.shift();
  skuData.shift();
  costosData.shift();
  ordersData.shift();

  // Crear mapa de precios de venta (el m谩s reciente por producto)
  const salePrices = {};
  const ORDERS_ITEM_NAME_COL = 8;
  const ORDERS_ITEM_PRICE_COL = 11;
  for (let i = ordersData.length - 1; i >= 0; i--) {
      const row = ordersData[i];
      const productName = row[ORDERS_ITEM_NAME_COL];
      const price = parseFloat(row[ORDERS_ITEM_PRICE_COL]);
      if (productName && !salePrices[productName] && price > 0) {
          salePrices[productName] = price;
      }
  }

  const skuMap = {};
  skuData.forEach(row => {
    const productoBase = row[1];
    if (!productoBase) return;
    if (!skuMap[productoBase]) skuMap[productoBase] = [];
    skuMap[productoBase].push({
      nombreProducto: row[0],
      cantidadVenta: parseFloat(String(row[6]).replace(',', '.')) || 0,
      unidadVenta: normalizeUnit(row[7])
    });
  });

  const historicalCosts = {};
  costosData.forEach(row => {
    const productName = row[1];
    const cost = parseFloat(row[2]);
    if (!productName || isNaN(cost)) return;
    if (!historicalCosts[productName]) historicalCosts[productName] = [];
    historicalCosts[productName].push(cost);
  });

  const analysisResults = [];
  const today = new Date();
  const todayString = today.toDateString();
  const processedProducts = new Set();

  const todayAcquisitions = historicoData.filter(acq => new Date(acq[1]).toDateString() === todayString);

  todayAcquisitions.forEach(acq => {
    const productoBase = acq[2];
    const formato = acq[3];
    const precioUnitario = parseFloat(String(acq[6]).replace(',', '.')) || 0;

    const match = formato.toString().match(/\((\d+(?:[.,]\d+)?)/);
    const formatoSize = match && match[1] ? parseFloat(match[1].replace(',', '.')) : 1;

    if (formatoSize === 0) return;
    const costoPorUnidadBase = precioUnitario / formatoSize;

    if (skuMap[productoBase]) {
      skuMap[productoBase].forEach(sku => {
        if (processedProducts.has(sku.nombreProducto)) return;

        const costoFinal = costoPorUnidadBase * sku.cantidadVenta;
        const history = historicalCosts[sku.nombreProducto] || [];
        const stats = calculateStats(history);

        let status = 'ok';
        let deviationLevel = 0;
        if (history.length < 2) {
            status = 'new';
        } else if (stats.stdDev > 0) {
            deviationLevel = (costoFinal - stats.mean) / stats.stdDev;
            if (Math.abs(deviationLevel) > DEVIATION_THRESHOLD) {
                status = 'anomaly';
            }
        }

        analysisResults.push({
          nombreProducto: sku.nombreProducto,
          costoHoy: costoFinal,
          status: status,
          productoBase: productoBase,
          formatoCompra: formato,
          proveedor: acq[8],
          precioUnitarioCompra: precioUnitario,
          costoPromedio: stats.mean,
          desviacionEstandar: stats.stdDev,
          nivelDesviacion: deviationLevel,
          precioVenta: salePrices[sku.nombreProducto] || 0
        });
        processedProducts.add(sku.nombreProducto);
      });
    }
  });

  return analysisResults;
}

/**
 * Muestra un di谩logo modal con las anomal铆as de precios para su aprobaci贸n.
 * @param {object} analysisData - El objeto que contiene allCosts y anomalies.
 */
function showPriceApprovalDashboard(analysisData) {
  const template = HtmlService.createTemplateFromFile('PriceApprovalDialog');
  template.analysisResults = analysisData;

  const html = template.evaluate()
      .setWidth(900)
      .setHeight(600);

  SpreadsheetApp.getUi().showModalDialog(html, 'Revisar y Aprobar Precios de Adquisici贸n');
}

/**
 * Guarda los datos de costos y anomal铆as aprobados en sus respectivas hojas.
 * Esta funci贸n es llamada desde el dashboard de aprobaci贸n.
 * @param {object} data - Un objeto que contiene las listas 'costs' y 'anomalies'.
 * @returns {string} Un mensaje de confirmaci贸n.
 */
function commitPriceData(data) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const costosSheet = ss.getSheetByName("CostosVenta");
  const anomaliasSheet = ss.getSheetByName("Anomal铆as de Precios");
  const today = new Date();
  const todayString = today.toDateString();

  try {
    // 1. Preparar los datos para escribir
    const costsToWrite = data.map(item => [today, item.nombreProducto, item.costoHoy]);

    const anomaliesToWrite = data
      .filter(item => item.status === 'anomaly')
      .map(a => [
        today, a.nombreProducto, a.costoHoy, a.costoPromedio, a.desviacionEstandar, a.nivelDesviacion,
        `Costo de hoy (${a.costoHoy.toFixed(2)}) se desv铆a en ${a.nivelDesviacion.toFixed(2)} stddevs.`
      ]);

    // 2. Guardar los costos de venta
    if (costsToWrite.length > 0) {
      const allCostosData = costosSheet.getDataRange().getValues();
      const rowsToDeleteCosts = [];
      allCostosData.forEach((row, index) => {
        if (index > 0 && new Date(row[0]).toDateString() === todayString) {
          rowsToDeleteCosts.push(index + 1);
        }
      });
      for (let i = rowsToDeleteCosts.length - 1; i >= 0; i--) {
        costosSheet.deleteRow(rowsToDeleteCosts[i]);
      }
      costosSheet.getRange(costosSheet.getLastRow() + 1, 1, costsToWrite.length, 3).setValues(costsToWrite);
    }

    // 3. Guardar las anomal铆as
    const allAnomaliasData = anomaliasSheet.getDataRange().getValues();
    const rowsToDeleteAnomalies = [];
    allAnomaliasData.forEach((row, index) => {
      if (index > 0 && new Date(row[0]).toDateString() === todayString) {
        rowsToDeleteAnomalies.push(index + 1);
      }
    });
    for (let i = rowsToDeleteAnomalies.length - 1; i >= 0; i--) {
      anomaliasSheet.deleteRow(rowsToDeleteAnomalies[i]);
    }

    if (anomaliesToWrite.length > 0) {
      anomaliasSheet.getRange(anomaliasSheet.getLastRow() + 1, 1, anomaliesToWrite.length, 7).setValues(anomaliesToWrite);
    }

    return "Los precios han sido aprobados y guardados correctamente.";

  } catch (e) {
    Logger.log(e);
    throw new Error("Ocurri贸 un error al guardar los datos: " + e.message);
  }
}


/**
 * Lee la hoja "Historico Adquisiciones" y devuelve un mapa de precios hist贸ricos por producto.
 * @returns {Object<string, Array<{date: Date, price: number}>>} Un mapa donde las claves son
 *   nombres de productos y los valores son arrays de objetos de precio, ordenados por fecha descendente.
 */
function getHistoricalPrices() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const historicoSheet = ss.getSheetByName("Historico Adquisiciones");
  const priceMap = {};

  if (!historicoSheet) {
    Logger.log("Advertencia: No se encontr贸 la hoja 'Historico Adquisiciones'. No se mostrar谩n precios.");
    return priceMap;
  }

  const lastRow = historicoSheet.getLastRow();
  if (lastRow < 2) {
    return priceMap; // Hoja vac铆a o solo con encabezados
  }

  // Columnas: B (Fecha de Registro), C (Producto Base), G (Precio Unitario)
  const data = historicoSheet.getRange(2, 2, lastRow - 1, 6).getValues();

  data.forEach(row => {
    const date = row[0];        // de la columna B
    const productName = row[1]; // de la columna C
    const price = row[5];       // de la columna G

    if (productName && date && price) {
      if (!priceMap[productName]) {
        priceMap[productName] = [];
      }
      priceMap[productName].push({
        date: new Date(date),
        price: parseFloat(String(price).replace(",", ".")) || 0
      });
    }
  });

  // Ordenar los precios de cada producto por fecha, de m谩s reciente a m谩s antiguo
  for (const product in priceMap) {
    priceMap[product].sort((a, b) => b.date - a.date);
  }

  return priceMap;
}

function getCurrentInventory() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const inventorySheet = ss.getSheetByName("Inventario Actual");
  const inventoryMap = {};

  if (!inventorySheet) {
    Logger.log("Warning: La hoja 'Inventario Actual' no fue encontrada. El inventario actual ser谩 0.");
    return inventoryMap;
  }

  const lastRow = inventorySheet.getLastRow();
  if (lastRow < 2) {
    return inventoryMap; // Sheet is empty or has only headers
  }

  // Read data from columns B (Producto Base), C (Cantidad Stock Real), D (Unidad Venta)
  const data = inventorySheet.getRange(2, 2, lastRow - 1, 3).getValues();

  data.forEach(row => {
    const productName = row[0]; // from column B
    const quantity = row[1];    // from column C
    const unit = row[2];        // from column D
    if (productName) {
      inventoryMap[productName] = {
        quantity: parseFloat(String(quantity).replace(",", ".")) || 0,
        unit: unit || ''
      };
    }
  });

  return inventoryMap;
}

// --- FUNCIONES AUXILIARES ---

/**
 * Calcula la media y la desviaci贸n est谩ndar de una poblaci贸n de un array de n煤meros.
 * @param {number[]} data - Un array de n煤meros.
 * @returns {{mean: number, stdDev: number}} Un objeto con la media y la desviaci贸n est谩ndar.
 */
function calculateStats(data) {
  if (!data || data.length === 0) {
    return { mean: 0, stdDev: 0 };
  }

  const n = data.length;
  const mean = data.reduce((a, b) => a + b, 0) / n;

  if (n < 2) {
    return { mean: mean, stdDev: 0 };
  }

  const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
  const stdDev = Math.sqrt(variance);

  return { mean: mean, stdDev: stdDev };
}

function parseDDMMYYYY(dateString) {
  if (!dateString || typeof dateString !== 'string') return null;
  const parts = dateString.split('/');
  if (parts.length !== 3) return null;
  // new Date(year, monthIndex, day)
  return new Date(parts[2], parts[1] - 1, parts[0]);
}

function extractNameFromDescription(description) {
  if (!description || typeof description !== 'string') return '';
  const match = description.match(/(?:transf de|de)\s(.+)/i);
  if (match && match[1]) {
    return match[1].replace(/[0-9]/g, '').trim();
  }
  let cleaned = description.replace(/transf/i, '')
                           .replace(/pago/i, '')
                           .replace(/[0-9]/g, '')
                           .trim();
  return cleaned;
}

function calculateNameSimilarity(nameFromPayment, nameFromOrder) {
  if (!nameFromPayment || !nameFromOrder) return 0;

  const normalize = (str) => str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").split(/\s+/);

  const wordsFromPayment = normalize(nameFromPayment);
  const wordsFromOrder = normalize(nameFromOrder);

  if (wordsFromPayment.length === 0 || wordsFromOrder.length === 0) return 0;

  let matches = 0;
  for (const pWord of wordsFromPayment) {
    for (const oWord of wordsFromOrder) {
      if (oWord.startsWith(pWord) || pWord.startsWith(oWord)) {
        matches++;
        break; 
      }
    }
  }
  
  return (matches / wordsFromPayment.length) * 100;
}

function normalizePhoneNumber(phone) {
  if (!phone) return '';
  const originalPhoneStr = String(phone);
  let phoneStr = originalPhoneStr.trim();

  // Clean up common prefixes like '=' or '+'
  if (phoneStr.startsWith('=') || phoneStr.startsWith('+')) {
    phoneStr = phoneStr.substring(1);
  }
  if (phoneStr.startsWith('+')) { // In case of '=+'
    phoneStr = phoneStr.substring(1);
  }

  // Handle the `...123` suffix
  if (phoneStr.endsWith('123')) {
    let coreNumber = phoneStr.slice(0, -3);
    if (coreNumber.length === 9 && coreNumber.startsWith('9')) {
      return `56${coreNumber}`;
    }
  }
  
  // Handle standard Chilean formats if the special suffix format didn't match
  if (phoneStr.startsWith('569') && phoneStr.length === 11) {
    return phoneStr;
  }
  if (phoneStr.length === 9 && phoneStr.startsWith('9')) {
    return `56${phoneStr}`;
  }
  if (phoneStr.length === 8) {
    return `569${phoneStr}`;
  }

  // Final Fallback: If no specific format was matched, strip all non-numeric characters.
  return originalPhoneStr.replace(/\D/g, '');
}

function getNewProducts(ordersSheet, skuSheet) {
  const ordersData = ordersSheet.getRange('J2:J' + ordersSheet.getLastRow()).getValues();
  const skuData = skuSheet.getRange('A2:A' + skuSheet.getLastRow()).getValues();
  const orderProducts = ordersData.map(row => row[0]).filter(String);
  const skuProducts = new Set(skuData.map(row => row[0]).filter(String));
  return [...new Set(orderProducts)].filter(product => !skuProducts.has(product));
}

function getSkuMap(skuSheet) {
  const skuData = skuSheet.getRange("A2:I" + skuSheet.getLastRow()).getValues();
  const skuMap = {};
  skuData.forEach(row => {
    let [name, base, format, qty, unit, category, saleQty, saleUnit, supplier] = row;
    if (name) {
      category = normalizeString(category);
      unit = normalizeUnit(unit);
      saleUnit = normalizeUnit(saleUnit);
      skuMap[name] = { base, format, qty, unit, category, saleQty, saleUnit, supplier };
    }
  });
  return skuMap;
}

function getPurchaseDataMaps(skuSheet) {
  const skuData = skuSheet.getRange("A2:I" + skuSheet.getLastRow()).getValues();
  const productToSkuMap = {};
  const baseProductPurchaseOptions = {};
  skuData.forEach(row => {
    const [nombreProducto, productoBase, formatoCompra, cantidadCompra, unidadCompra, cat, cantVenta, unidadVenta, proveedor] = row;
    if (nombreProducto) {
      productToSkuMap[nombreProducto] = {
        productoBase,
        cantidadVenta: parseFloat(String(cantVenta).replace(',', '.')) || 0,
        unidadVenta: normalizeUnit(unidadVenta)
      };
    }
    if (productoBase && formatoCompra) {
      if (!baseProductPurchaseOptions[productoBase]) {
        baseProductPurchaseOptions[productoBase] = { options: [], suppliers: new Set() };
      }
      baseProductPurchaseOptions[productoBase].options.push({
        name: formatoCompra,
        size: parseFloat(String(cantidadCompra).replace(',', '.')) || 0,
        unit: normalizeUnit(unidadCompra)
      });
      if (proveedor) baseProductPurchaseOptions[productoBase].suppliers.add(proveedor);
    }
  });
  return { productToSkuMap, baseProductPurchaseOptions };
}

function calculateBaseProductNeeds(ordersSheet, productToSkuMap) {
  const orderData = ordersSheet.getRange("J2:K" + ordersSheet.getLastRow()).getValues();
  const baseProductNeeds = {};
  orderData.forEach(([name, qty]) => {
    if (name && qty && productToSkuMap[name]) {
      const skuInfo = productToSkuMap[name];
      const baseProduct = skuInfo.productoBase;
      const saleUnit = normalizeUnit(skuInfo.unidadVenta);
      const totalSaleAmount = (parseInt(qty, 10) || 0) * skuInfo.cantidadVenta;
      if (!baseProductNeeds[baseProduct]) baseProductNeeds[baseProduct] = {};
      if (!baseProductNeeds[baseProduct][saleUnit]) baseProductNeeds[baseProduct][saleUnit] = 0;
      baseProductNeeds[baseProduct][saleUnit] += totalSaleAmount;
    }
  });
  return baseProductNeeds;
}

function createAcquisitionPlan(baseProductNeeds, baseProductPurchaseOptions) {
  const acquisitionPlan = {};
  for (const baseProduct in baseProductNeeds) {
    if (baseProductPurchaseOptions[baseProduct]) {
      const needs = baseProductNeeds[baseProduct];
      const purchaseInfo = baseProductPurchaseOptions[baseProduct];
      const purchaseOptions = purchaseInfo.options;
      const needUnit = Object.keys(needs)[0];
      const totalNeed = needs[needUnit];
      let bestOption = null;
      let minWaste = Infinity;
      purchaseOptions.forEach((option) => {
        if (option.unit === needUnit && option.size > 0) {
          const numToBuy = Math.ceil(totalNeed / option.size);
          const waste = (numToBuy * option.size) - totalNeed;
          if (waste < minWaste) {
            minWaste = waste;
            bestOption = { ...option, suggestedQty: numToBuy };
          }
        }
      });
      if (bestOption) {
        acquisitionPlan[baseProduct] = {
          productName: baseProduct,
          totalNeed,
          unit: needUnit,
          saleUnit: needUnit,
          supplier: Array.from(purchaseInfo.suppliers).join(', '),
          availableFormats: purchaseOptions,
          suggestedFormat: bestOption,
          suggestedQty: bestOption.suggestedQty
        };
      }
    }
  }
  return acquisitionPlan;
}

function groupPlanBySupplier(acquisitionPlan) {
  const dataBySupplier = {};
  for (const productName in acquisitionPlan) {
    const productData = acquisitionPlan[productName];
    const supplier = productData.supplier || "Sin Proveedor";
    if (!dataBySupplier[supplier]) dataBySupplier[supplier] = [];
    dataBySupplier[supplier].push(productData);
  }
  return dataBySupplier;
}

function normalizeString(str) {
  if (!str || typeof str !== 'string') return '';
  return str.trim().toLowerCase().replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));
}

function normalizeUnit(str) {
  if (!str || typeof str !== 'string') return '';
  const s = str.trim().toLowerCase();
  if (s.startsWith('kilo')) { return 'Kg';}
  if (s.startsWith('gr')) { return 'Gr';}
  if (s.startsWith('unidad')) { return 'Unidad';}
  if (s.startsWith('bandeja')) { return 'Bandeja';}
  return normalizeString(s);
}

function getOAuthToken() {
  DriveApp.getFolderById('root'); // Force Drive scope.
  return ScriptApp.getOAuthToken();
}

function importOrdersFromXLSX(fileId) {
  let tempSheetId = null;
  try {
    const resource = {
      title: `[Temp] Importaci贸n de Pedidos - ${new Date().toISOString()}`,
      mimeType: MimeType.GOOGLE_SHEETS
    };
    const tempFile = Drive.Files.copy(resource, fileId);
    tempSheetId = tempFile.id;
    const tempSpreadsheet = SpreadsheetApp.openById(tempSheetId);
    const tempSheet = tempSpreadsheet.getSheets()[0];
    const data = tempSheet.getDataRange().getValues();
    if (!data || data.length < 2) {
      throw new Error("El archivo seleccionado est谩 vac铆o o no tiene datos.");
    }
    const mainSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = mainSpreadsheet.getSheetByName("Orders");
    if (!ordersSheet) {
      throw new Error("No se encontr贸 la hoja 'Orders' en el libro principal.");
    }
    ordersSheet.getRange("A2:Z").clearContent();
    ordersSheet.getRange(2, 1, data.length - 1, data[0].length).setValues(data.slice(1));
    return `隆xito! Se han importado ${data.length - 1} filas de pedidos.`;
  } catch (e) {
    Logger.log(`Error en importOrdersFromXLSX: ${e.toString()}`);
    throw new Error(`Ocurri贸 un error durante la importaci贸n: ${e.message}`);
  } finally {
    if (tempSheetId) {
      Drive.Files.remove(tempSheetId);
      Logger.log(`Archivo temporal eliminado: ${tempSheetId}`);
    }
  }
}

function formatPhoneNumbersInOrdersSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("Orders");
  if (!sheet) {
    SpreadsheetApp.getUi().alert("No se encontr贸 la hoja 'Orders'.");
    return;
  }
  
  const phoneColumn = 4; // Column D
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    SpreadsheetApp.getUi().alert("No hay datos para formatear en la hoja 'Orders'.");
    return;
  }

  const phoneRange = sheet.getRange(2, phoneColumn, lastRow - 1, 1);
  const phoneValues = phoneRange.getValues();
  
  let changedCount = 0;
  const formattedPhones = phoneValues.map(row => {
    const originalPhone = row[0];
    if (!originalPhone) return [originalPhone];
    
    const formatted = normalizePhoneNumber(originalPhone);
    if (formatted !== originalPhone) {
      changedCount++;
    }
    return [formatted];
  });

  phoneRange.setValues(formattedPhones);
  
  SpreadsheetApp.getUi().alert(`Proceso completado. Se revisaron ${phoneValues.length} n煤meros. Se corrigieron ${changedCount} n煤meros de tel茅fono.`);
}
